// Generated by CoffeeScript 2.3.2
(function() {
  var Q, Storage,
    indexOf = [].indexOf;

  Storage = class Storage {
    
    // Store some user stuff in local or session storage
    constructor() {
      var getBoolValue, isNull, setAvailableLevel, setShowCursor;
      console.log('storage constructor');
      this.prefix = "zombiegame:";
      this.storage = localStorage; // TODO: revert to sessionStorage if permission denied 
      this.storageKeys = {
        availableLevel: this.prefix + "availableLevel",
        levelProgress: this.prefix + "levelProgress",
        showCursor: this.prefix + "showCursor"
      };
      getBoolValue = (key) => {
        var stringVal;
        stringVal = this.storage.getItem(key);
        return true.toString() === stringVal;
      };
      isNull = (key) => {
        var stringVal;
        stringVal = this.storage.getItem(key);
        return stringVal === null;
      };
      setAvailableLevel = (level) => {
        return this.storage.setItem(this.storageKeys.availableLevel, level);
      };
      setShowCursor = (show_cursor) => {
        return this.storage.setItem(this.storageKeys.showCursor, show_cursor);
      };
      // Populate
      if (isNull(this.storageKeys.availableLevel)) {
        setAvailableLevel(1);
      }
      if (isNull(this.storageKeys.showCursor)) {
        setShowCursor(true);
      }
      Game.availableLevel = this.storage.getItem(this.storageKeys.availableLevel);
      Game.showCursor = this.storage.getItem(this.storageKeys.showCursor);
      Game.moreLevelsPage = 0;
    }

  };

  // main game object
  window.Game = {
    init: function() {
      var Q, boolValueOrDefault, element;
      // engine instance
      this.Q = Q = Quintus({
        development: true,
        audioSupported: ['ogg', 'mp3']
      });
      // Q.debug = true
      // Q.debugFill = true

      // main setup
      Q.include("Sprites, Scenes, Input, Touch, Gaze, UI, 2D, Anim, Audio");
      Q.setup({
        // width: 640
        // height: 320
        maximize: true,
        upsampleWidth: 640,
        upsampleHeight: 320
      });
      Q.controls().touch(Q.SPRITE_UI, [0, 1]);
      Q.controls().trackGaze(Q.SPRITE_UI, [0, 1, 2]);
      Q.enableSound();
      // game progress
      Game.storageKeys = {
        availableLevel: "zombieGame:availableLevel",
        levelProgress: "zombieGame:levelProgress",
        showCursor: "zombieGame:showCursor",
        unlockedBonus: "zombieGame:unlockedBonus"
      };
      Game.availableLevel = localStorage.getItem(Game.storageKeys.availableLevel) || 1;
      boolValueOrDefault = (key, defaultVal) => {
        var stringVal;
        stringVal = localStorage.getItem(key);
        if (stringVal === null) {
          return defaultVal;
        } else {
          if (stringVal === false.toString()) {
            return false;
          } else if (stringVal === true.toString()) {
            return true;
          } else {
            console.error(`Cannot read bool value for key ${key}`);
            return defaultVal;
          }
        }
      };
      Game.showCursor = boolValueOrDefault(Game.storageKeys.showCursor, true);
      Game.unlockedBonus = boolValueOrDefault(Game.storageKeys.unlockedBonus, false);
      
      // Stuff that gets modified by user
      // TODO: store this!
      Game.preferences = {
        'uiScale': 1.0,
        'narrate': false,
        'dwellTime': 1.0
      };
      Game.uiScale = 1.0;
      // used for collision detection
      this.SPRITE_NONE = 0;
      this.SPRITE_PLAYER = 1;
      this.SPRITE_TILES = 2;
      this.SPRITE_ENEMY = 4;
      this.SPRITE_BULLET = 8;
      this.SPRITE_PLAYER_COLLECTIBLE = 16;
      this.SPRITE_HUMAN = 32;
      this.SPRITE_ZOMBIE_PLAYER = 64;
      this.SPRITE_ALL = 0xFFFF;
      // rest of init
      this.prepareAssets();
      this.initStats();
      this.initUnloadEvent();
      // helpers
      Q.tilePos = function(col, row, otherParams = {}) {
        var position;
        position = {
          x: col * Game.assets.map.tileSize + Game.assets.map.tileSize / 2,
          y: row * Game.assets.map.tileSize + Game.assets.map.tileSize / 2
        };
        return Q._extend(position, otherParams);
      };
      if (!Game.showCursor) {
        element = document.getElementById("quintus_container");
        element.style.cursor = "none";
      }
    },
    // one place of defining assets
    prepareAssets: function() {
      var assetsAsArray, audioAsArray, k, level_assets, levels, v;
      levels = {
        tutorial: {
          dataAsset: "tutorial.tmx",
          bullets: 20
        },
        level1: {
          dataAsset: "level1.tmx",
          bullets: 4
        },
        level2: {
          dataAsset: "level2.tmx",
          bullets: 8
        },
        level3: {
          dataAsset: "level3.tmx",
          bullets: 6
        },
        level4: {
          dataAsset: "level4.tmx",
          bullets: 6
        },
        level5: {
          dataAsset: "level5.tmx",
          bullets: 15
        },
        level6: {
          dataAsset: "steps.tmx",
          bullets: 10,
          name: "Steps"
        },
        level7: {
          dataAsset: "hurdles.tmx",
          bullets: 10,
          name: "Hurdles"
        },
        level8: {
          dataAsset: "pyramid.tmx",
          bullets: 10,
          name: "Pyramid"
        },
        level9: {
          dataAsset: "diamond.tmx",
          bullets: 20,
          name: "Diamond"
        },
        level10: {
          dataAsset: "trickyJumps.tmx",
          bullets: 10,
          name: "Tricky Jumps"
        },
        level11: {
          dataAsset: "tooManyZombies.tmx",
          bullets: 20,
          name: "Too Many Zombies"
        },
        level12: {
          dataAsset: "trickyJumpsMore.tmx",
          bullets: 20,
          name: "More Tricky Jumps"
        }
      };
      
      // split into array for accessing level details by index
      // and data assets strings for loading 
      this.levels_array = [];
      level_assets = [];
      for (k in levels) {
        v = levels[k];
        this.levels_array.push(v);
        level_assets.push(v.dataAsset);
      }
      // all assets, only file names
      this.assets = {
        characters: {
          dataAsset: "characters.json",
          sheet: "characters.png"
        },
        controls: {
          dataAsset: "controls.json",
          sheet: "controls.png"
        },
        items: {
          dataAsset: "items.json",
          sheet: "items.png"
        },
        hud: {
          dataAsset: "hud.json",
          sheet: "hud.png"
        },
        others: {
          dataAsset: "others.json",
          sheet: "others.png"
        },
        misc: {
          dataAsset: "misc.json",
          sheet: "misc.png"
        },
        bullet: {
          dataAsset: "bullet.json",
          sheet: "bullet.png"
        },
        map: {
          sheet: "map_tiles.png"
        },
        gradient: "gradient-top.png",
        tutorial: {
          dataAsset: "tutorial.tmx"
        }
      };
      
      // audio
      this.audio = {
        zombieMode: "zombie_mode.mp3",
        playerBg: "player_bg.mp3",
        zombieNotice: "zombie_notice.mp3",
        gunShot: "gun_shot.mp3",
        collected: "collected.mp3",
        playerHit: "player_hit.mp3",
        humanCreated: "human_created.mp3"
      };
      Game.isMuted = false;
      // convert to array for Q.load    
      assetsAsArray = [];
      this.objValueToArray(this.assets, assetsAsArray);
      // now we can add metadata
      this.assets.map.sheetName = "tiles";
      this.assets.map.tileSize = 70;
      // convert @audio to array
      audioAsArray = [];
      this.objValueToArray(this.audio, audioAsArray);
      // merge assets and audio for Q.load
      return this.assets.all = assetsAsArray.concat(audioAsArray).concat(level_assets);
    },
    // helper to conver obj to array
    objValueToArray: function(obj, array) {
      var key, results, value;
      results = [];
      for (key in obj) {
        value = obj[key];
        if (typeof value === 'string') {
          results.push(array.push(value));
        } else {
          results.push(this.objValueToArray(value, array));
        }
      }
      return results;
    },
    initStats: function() {
      var stats;
      this.Q.stats = stats = new Stats();
      return stats.setMode(0); // 0: fps, 1: ms
    },
    
    // Align top-left
    // stats.domElement.style.position = 'absolute'
    // stats.domElement.style.left = '0px'
    // stats.domElement.style.top = '140px'

    // document.body.appendChild( stats.domElement )
    stageLevel: function(number = 1) {
      var Q, level, level_data, num_bullets;
      Q = this.Q;
      Q.state.reset({
        enemiesCounter: 0,
        lives: 5,
        bullets: 0,
        hasKey: false,
        hasGun: false,
        currentLevel: number, // for saving the progress
        canEnterDoor: false
      });
      Game.currentLevelData = { // for level summary
        zombies: {
          healed: 0,
          available: 0
        },
        health: {
          collected: 0,
          available: 0
        },
        bullets: {
          waisted: 0,
          available: 0
        },
        zombieModeFound: false
      };
      // Q.input.touchControls() # render onscreen touch buttons
      Q.clearStages();
      level = Game.levels_array[number];
      // levels are constructed on the fly
      level_data = level.dataAsset;
      num_bullets = level.bullets;
      Q.scene("level", function(stage) {
        return Q.LevelParser.default_load_level(stage, level_data, num_bullets);
      });
      Q.stageScene("level", {
        sort: true
      });
      Q.stageScene("hud", 2, {
        sort: true
      });
      Q.stageScene("gaze_overlay", 1, {
        sort: true
      });
      // the story
      Game.infoLabel.intro();
      // for analytics
      Game.currentScreen = "level" + number;
      // unlock the next level
      if (number >= Game.availableLevel) {
        Game.availableLevel = number + 1;
        return localStorage.setItem(Game.storageKeys.availableLevel, Game.availableLevel);
      }
    },
    stageLevelSelectScreen: function() {
      this.Q.input.disableTouchControls();
      // reset current level state
      this.Q.state.set("currentLevel", 0);
      this.Q.clearStages();
      this.Q.stageScene("levelSelect");
      console.log(Q.width);
      console.log(Q.height);
      // for analytics
      return Game.currentScreen = "levelSelect";
    },
    stageEndLevelScreen: function() {
      this.Q.input.disableTouchControls();
      this.Q.clearStages();
      this.Q.stageScene("levelSummary", Game.currentLevelData);
      // for analytics
      return Game.currentScreen = "levelSummary for level" + this.Q.state.get("currentLevel");
    },
    stageEndScreen: function() {
      this.Q.input.disableTouchControls();
      this.Q.clearStages();
      this.Q.stageScene("end");
      // for analytics
      Game.currentScreen = "end";
      // track events
      return Game.trackEvent("End Screen", "displayed");
    },
    stageScreen: function(screen_name) {
      this.Q.clearStages();
      this.Q.stageScene(screen_name);
      // for analytics
      return Game.currentScreen = screen_name;
    },
    stageMoreLevels: function(page) {
      var max_pages, screen_name;
      max_pages = Math.ceil(Game.levels_array.length - 6) / 4;
      if (page >= 0 && page <= max_pages) {
        screen_name = "levelSelectMore";
        Game.moreLevelsPage = page;
        this.Q.clearStages();
        this.Q.stageScene(screen_name);
        // for analytics
        return Game.currentScreen = screen_name;
      }
    },
    stageTutorial: function() {
      var Q;
      Q = this.Q;
      Q.state.reset({
        enemiesCounter: 0,
        lives: 5,
        bullets: 0,
        hasKey: false,
        hasGun: false,
        currentLevel: 0, // for saving the progress
        canEnterDoor: false
      });
      Game.currentLevelData = { // for level summary
        zombies: {
          healed: 0,
          available: 0
        },
        health: {
          collected: 0,
          available: 0
        },
        bullets: {
          waisted: 0,
          available: 0
        },
        zombieModeFound: false
      };
      // Q.input.touchControls() # render onscreen touch buttons
      Q.clearStages();
      Q.stageScene("tutorial", {
        sort: true
      });
      Q.stageScene("hud", 2, {
        sort: true
      });
      Q.stageScene("gaze_overlay", 1, {
        sort: true
      });
      // the story
      Game.infoLabel.tutorial();
      // for analytics
      return Game.currentScreen = "tutorial";
    },
    stageGameOverScreen: function() {
      this.Q.clearStages();
      this.Q.stageScene("gameOver");
      // for analytics
      Game.currentScreen = "gameOver";
      // track events
      return Game.trackEvent("Game Over Screen", "displayed");
    },
    setCameraTo: function(stage, toFollowObj) {
      return stage.follow(toFollowObj, {
        x: true,
        y: true
      }, {
        minX: 0,
        maxX: Game.map.p.w,
        minY: 0,
        maxY: Game.map.p.h
      });
    },
    trackEvent: function(category, action, label, value) {
      if (false) { // we've turned off google analytics for now
        if (label == null) {
          return ga('send', 'event', category, action);
        } else if (value == null) {
          return ga('send', 'event', category, action, label.toString());
        } else {
          // console.log('_gaq.push', category + ' | ', action + ' | ', label.toString())
          return ga('send', 'event', category, action, label.toString(), parseInt(value, 10));
        }
      }
    },
    // console.log('_gaq.push', category + ' | ', action + ' | ', label.toString() + ' | ', parseInt(value, 10))
    initUnloadEvent: function() {
      return window.addEventListener("beforeunload", function(e) {
        return Game.trackEvent("Unload", "Current Screen", Game.currentScreen);
      });
    },
    add_door_button: function(stage, doorPos) {
      var Q;
      Q = this.Q;
      return stage.insert(new Q.UI.DoorButton({
        x: doorPos.x,
        y: doorPos.y - 2.5 * Game.assets.map.tileSize
      }));
    }
  };

  
  // init game
  Game.init();

  Q = Game.Q;

  Q.AudioManager = {
    collection: [],
    muted: false,
    add: function(audio, options) {
      var alreadyAdded, item;
      item = {
        audio: audio,
        options: options
      };
      if ((options != null ? options.loop : void 0) === true) {
        alreadyAdded = this.find(audio);
        if (alreadyAdded === false) {
          this.collection.push(item);
        }
      }
      if (!this.muted) {
        return Q.audio.play(item.audio, item.options);
      }
    },
    remove: function(audio) {
      var indexToRemove;
      indexToRemove = null;
      indexToRemove = this.find(audio);
      if (indexToRemove >= 0) {
        Q.audio.stop(this.collection[indexToRemove].audio);
        return this.collection.splice(indexToRemove, 1);
      }
    },
    find: function(audio) {
      var index, item, j, len, ref;
      ref = this.collection;
      for (index = j = 0, len = ref.length; j < len; index = ++j) {
        item = ref[index];
        if (item.audio === audio) {
          return index;
        }
      }
      return false;
    },
    playAll: function() {
      var item, j, len, ref, results;
      ref = this.collection;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        item = ref[j];
        results.push(Q.audio.play(item.audio, item.options));
      }
      return results;
    },
    stopAll: function() {
      return Q.audio.stop();
    },
    clear: function() {
      return this.collection = [];
    },
    mute: function() {
      this.muted = true;
      return this.stopAll();
    },
    unmute: function() {
      this.muted = false;
      return this.playAll();
    }
  };

  Q = Game.Q;

  Q.LevelParser = {
    // NB most of these methods modifies the global Game object
    default_load_level: function(stage, data_asset, bullets_per_gun) {
      var background, objects;
      // If no customisation is required, this encapsulates all level loading      

      // main map with collision
      Game.map = this.load_map(data_asset, Game.SPRITE_TILES, 0);
      stage.collisionLayer(Game.map);
      
      // background decorations
      background = this.load_map(data_asset, Game.SPRITE_NONE, 1);
      stage.insert(background);
      // all other objects (player, zombies, gun, health, door etc)
      objects = this.parse_objects(data_asset, []);
      this.load_objects(stage, objects, bullets_per_gun);
      // store level data for level summary
      Game.currentLevelData.health.available = stage.lists.Heart.length;
      return Game.currentLevelData.zombies.available = stage.lists.Zombie.length;
    },
    load_map: function(data_asset, sprite_type, layer_index) {
      return new Q.TileLayer({
        type: sprite_type,
        layerIndex: layer_index,
        dataAsset: data_asset,
        sheet: Game.assets.map.sheetName,
        tileW: Game.assets.map.tileSize,
        tileH: Game.assets.map.tileSize,
        z: 2
      });
    },
    parse_objects: function(dataAsset, ignore_objects) {
      var data, doc, fileExt, fileParts, item, j, len, name, name_lowercase, obj, objects, parser;
      fileParts = dataAsset.split(".");
      fileExt = fileParts[fileParts.length - 1].toLowerCase();
      if (fileExt === "tmx" || fileExt === "xml") {
        parser = new DOMParser();
        doc = parser.parseFromString(Q.asset(dataAsset), "application/xml");
        objects = doc.getElementsByTagName("object");
        data = [];
        for (j = 0, len = objects.length; j < len; j++) {
          obj = objects[j];
          name_lowercase = obj.getAttribute('name');
          // capitalise first letter
          name = name_lowercase.charAt(0).toUpperCase() + name_lowercase.slice(1);
          
          // legacy inconsistencies
          if (name === "Health") {
            name = "Heart";
          }
          if (indexOf.call(ignore_objects, name) < 0) {
            item = {
              name: name,
              x: obj.getAttribute('x') / Game.assets.map.tileSize,
              y: obj.getAttribute('y') / Game.assets.map.tileSize,
              w: obj.getAttribute('width') / Game.assets.map.tileSize,
              h: obj.getAttribute('height') / Game.assets.map.tileSize
            };
            data.push(item);
          }
        }
        return data;
      } else {
        throw "file type not supported";
      }
    },
    load_objects: function(stage, objects, bullets_per_gun) {
      var all_items, item, j, len, obj, player, randomBool, ref;
      all_items = [];
      for (j = 0, len = objects.length; j < len; j++) {
        obj = objects[j];
        if ((ref = obj.name) === "Key" || ref === "Gun" || ref === "Zombie" || ref === "Door" || ref === "Player" || ref === "Heart" || ref === "Health") {
          if (obj.name === "Gun") {
            // Add bullets
            item = [
              obj.name,
              Q.tilePos(obj.x,
              obj.y,
              {
                bullets: bullets_per_gun
              })
            ];
            all_items.push(item);
          } else if (obj.name === "Zombie") {
            // Face random direction
            randomBool = Math.floor(Math.random() * 2);
            console.log(randomBool);
            item = [
              obj.name,
              Q.tilePos(obj.x,
              obj.y,
              {
                startLeft: randomBool,
                canFallOff: false
              })
            ];
            all_items.push(item);
          } else if (obj.name === "Player") {
            // Player and camera together, get added differently
            Game.player = player = stage.insert(new Q.Player(Q.tilePos(obj.x, obj.y)));
            stage.add("viewport");
            Game.setCameraTo(stage, player);
          } else if (obj.name === "Door") {
            all_items.push([obj.name, Q.tilePos(obj.x, obj.y)]);
            
            // Add door button for gaze
            Game.add_door_button(stage, Q.tilePos(obj.x, obj.y));
          } else {
            item = [obj.name, Q.tilePos(obj.x, obj.y)];
            all_items.push(item);
          }
        } else {
          console.log(`Cannot create object: ${obj.name}`);
        }
      }
      return stage.loadAssets(all_items);
    }
  };

  Q = Game.Q;

  Q.load(Game.assets.all, function() {
    // prepare sheets
    Q.sheet(Game.assets.map.sheetName, Game.assets.map.sheet, {
      tileW: Game.assets.map.tileSize,
      tileH: Game.assets.map.tileSize
    });
    Q.compileSheets(Game.assets.characters.sheet, Game.assets.characters.dataAsset);
    Q.compileSheets(Game.assets.items.sheet, Game.assets.items.dataAsset);
    Q.compileSheets(Game.assets.hud.sheet, Game.assets.hud.dataAsset);
    Q.compileSheets(Game.assets.misc.sheet, Game.assets.misc.dataAsset);
    Q.compileSheets(Game.assets.others.sheet, Game.assets.others.dataAsset);
    Q.compileSheets(Game.assets.bullet.sheet, Game.assets.bullet.dataAsset);
    Q.compileSheets(Game.assets.controls.sheet, Game.assets.controls.dataAsset);
    // first stage
    return Game.stageScreen("start");
  }, {
    progressCallback: function(loaded, total) {
      var container, element;
      element = document.getElementById("loading-progress");
      element.style.width = Math.floor(loaded / total * 100) + "%";
      if (loaded === total) {
        container = document.getElementById("loading");
        return container.parentNode.removeChild(container);
      }
    }
  });

  Q = Game.Q;

  Q.component("gun", {
    added: function() {
      var p;
      Q.input.on("fire", this.entity, "fireGun");
      p = this.entity.p;
      // animations
      p.sheet = "player_with_gun";
      p.sprite = "playerWithGun";
      this.entity.play("stand");
      // if component added not by collecting gun item
      if (Q.state.get("bullets") > 0) {
        p.noOfBullets = Q.state.get("bullets");
      }
      // do not allow to fire in series
      return p.nextFireTimeout = 0;
    },
    destroyed: function() {
      return Q.input.off("fire", this.entity);
    },
    extend: {
      gunStep: function(dt) {
        if (this.p.nextFireTimeout > 0) {
          return this.p.nextFireTimeout = Math.max(this.p.nextFireTimeout - dt, 0);
        }
      },
      fireGun: function() {
        var bullet, delta;
        if (this.p.nextFireTimeout === 0) {
          this.p.nextFireTimeout = 0.5;
          // fire
          if (this.p.noOfBullets > 0) {
            if (this.p.direction === "left") {
              delta = -15;
            } else {
              delta = 15;
            }
            Q.AudioManager.add(Game.audio.gunShot);
            bullet = this.stage.insert(new Q.Bullet({
              x: this.p.x + delta,
              y: this.p.y + 3,
              direction: this.p.direction
            }));
          } else {
            Game.infoLabel.outOfBullets();
          }
          // first fire, then update counter
          this.p.noOfBullets -= 1;
          if (this.p.noOfBullets >= 0) {
            return Q.state.set("bullets", this.p.noOfBullets);
          }
        }
      }
    }
  });

  Q = Game.Q;

  Q.component("zombieAI", {
    added: function() {
      var p;
      p = this.entity.p;
      p.fullSpeed = 60;
      if (p.startLeft) {
        p.vx = p.fullSpeed;
      } else {
        p.vx = -p.fullSpeed;
      }
      return p.audioTimeout = 0;
    },
    extend: {
      zombieStep: function(dt) {
        var cliffAhead, currentlyChasing, dirX, ground, inFront, inFrontPlayer, inFrontTile, nextTile, playerInvincible, stopChasing;
        // some AI - always try to catch player
        this.canSeeThePlayer(); // create @canSeeThePlayerObj object
        
        // stop chasing while player invincible
        playerInvincible = this.isPlayerInvincible();
        if (playerInvincible) {
          this.p.canSeeThePlayerTimeout = 0;
        } else if (this.canSeeThePlayerObj.status) {
          // I see the player, I will remember that for X sec
          this.p.canSeeThePlayerTimeout = 2;
          if (this.canSeeThePlayerObj.playAudio) {
            if (this.p.audioTimeout === 0) {
              Q.AudioManager.add(Game.audio.zombieNotice);
              this.play("attack", 10);
              this.p.audioTimeout = 10;
            }
          }
          if ((this.canSeeThePlayerObj.left && this.p.vx > 0) || (this.canSeeThePlayerObj.right && this.p.vx < 0)) {
            // enemy goes in wrong direction, change it
            this.p.vx = -Math.sign(this.p.vx) * this.p.fullSpeed;
          }
        } else {
          // run timeout
          this.p.canSeeThePlayerTimeout = Math.max(this.p.canSeeThePlayerTimeout - dt, 0);
        }
        // count always
        this.p.audioTimeout = Math.max(this.p.audioTimeout - dt, 0);
        // locate gap and turn back
        dirX = this.p.vx / Math.abs(this.p.vx); // or Math.sign(@p.vx) !
        ground = Q.stage().locate(this.p.x, this.p.y + this.p.h / 2 + 1, Game.SPRITE_TILES);
        nextTile = Q.stage().locate(this.p.x + dirX * this.p.w / 2 + dirX, this.p.y + this.p.h / 2 + 1, Game.SPRITE_TILES);
        inFrontTile = Q.stage().locate(this.p.x + dirX * this.p.w / 2 + dirX, this.p.y, Game.SPRITE_TILES);
        inFrontPlayer = Q.stage().locate(this.p.x + dirX * this.p.w / 2 + dirX, this.p.y, Game.SPRITE_PLAYER);
        inFront = inFrontTile || inFrontPlayer;
        cliffAhead = !nextTile && ground;
        // if player is invincible, we'll stop chasing as soon as attack animation finished
        stopChasing = playerInvincible && this.p.animation !== "attack";
        currentlyChasing = !stopChasing && (this.canSeeThePlayerObj.status || this.p.canSeeThePlayerTimeout > 0);
        if (cliffAhead) {
          if (!currentlyChasing) {
            if (this.p.vx > 0) {
              // turn around 
              this.p.vx = -Math.sign(this.p.vx) * this.p.fullSpeed;
            } else {
              // turn around 
              if (this.p.flip) {
                this.p.vx = this.p.fullSpeed;
              } else {
                this.p.vx = -this.p.fullSpeed;
              }
            }
          } else if (currentlyChasing && !this.p.canFallOff) {
            // keep facing player, but don't fall off
            this.p.vx = 0;
          }
        }
        // if there's an obstacle in front
        if (inFront && !currentlyChasing) {
          // turn around 
          this.p.vx = -Math.sign(this.p.vx) * this.p.fullSpeed;
        }
        // set the correct direction of sprite
        return this.flip();
      },
      flip: function() {
        if (Math.abs(this.p.vx) > 0) {
          if (this.p.vx > 0) {
            return this.p.flip = false;
          } else {
            return this.p.flip = "x";
          }
        }
      },
      isPlayerInvincible: function() {
        var player;
        player = Game.player.p;
        return ((player != null ? player.isDestroyed : void 0) == null) && player.timeInvincible > 0;
      },
      canSeeThePlayer: function() {
        var isCloseFromLeft, isCloseFromRight, isTheSameY, lineOfSight, oldObj, player;
        player = Game.player.p;
        lineOfSight = 350;
        oldObj = this.canSeeThePlayerObj;
        this.canSeeThePlayerObj = {
          playAudio: true,
          status: false
        };
        if ((oldObj != null ? oldObj.status : void 0) === true) {
          this.canSeeThePlayerObj.playAudio = false;
        }
        if (Game.player.isDestroyed != null) {
          return;
        }
        // is player on the same level as enemy?
        isTheSameY = player.y > this.p.y - 10 && player.y < this.p.y + 10;
        // is player in the near of the enemy?
        this.canSeeThePlayerObj.left = isCloseFromLeft = (player.x > this.p.x - lineOfSight) && player.x < this.p.x;
        this.canSeeThePlayerObj.right = isCloseFromRight = (player.x < this.p.x + lineOfSight) && player.x > this.p.x;
        if (isTheSameY && (isCloseFromLeft || isCloseFromRight)) {
          this.canSeeThePlayerObj.status = true;
        } else {
          this.canSeeThePlayerObj.status = false;
          this.canSeeThePlayerObj.playAudio = true;
        }
      }
    }
  });

  Q = Game.Q;

  Q.scene("about", function(stage) {
    var authors, button, buttonTextSize, desc, description, label, title, titleContainer, y_pad;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    // description = "Imagine, what if the cure exists?\n"
    description = "Heal 'em all was designed and written by Kris Urbas (programming, story)\n";
    description += "and Pawel Madeja (graphics) and was one of the GitHub Game Jam 2013 winners.\n";
    description += "\n";
    description += "They kindly gave permission for SpecialEffect to adapt the game for an\n";
    description += "eye gaze audience in 2019. \n";
    description += "\n";
    description += "The game uses the Quintus game engine under the MIT license, \n";
    description += "and audio from https://opengameart.org/\n";
    // TODO link to https://raw.githubusercontent.com/cykod/Quintus/master/MIT-LICENSE.txt
    // probably a link to github where we can more easily detail things / give links
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#000000",
      family: "Jolly Lodger",
      size: 36
    }));
    // panel
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: desc.p.w * 1.1,
      h: desc.p.h * 1.1,
      z: desc.p.z - 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: desc.p.y - desc.p.h / 2,
      label: "Heal'em All",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 90
    }));
    title.p.y = title.p.y - title.p.h / 2 - y_pad;
    title.size();
    // button
    label = "Back";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: desc.p.y + desc.p.h / 2,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.p.y = button.p.y + button.p.h / 2 + y_pad * 2;
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("controls", function(stage) {
    var button, cell1, cell2, cell3, cell4, columnInP, columnWidth, columnsNo, gutterX, gutterXinP, marginX, marginXinP, marginY, numberpad, row2offset, rowHeight, sprite, step1text, step2text, step3text, step4text, title, x_pad;
    // some math
    marginY = Q.height * 0.15;
    marginXinP = 10; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    rowHeight = Q.height * 0.3;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // add title
    title = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY,
      label: "How to heal’em",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 60
    }));
    // add cells, 2x2
    x_pad = -50; // to account for images on right of centralised text
    cell1 = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2 + x_pad,
      y: Q.height / 2 - rowHeight / 2 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    cell2 = stage.insert(new Q.UI.Container({
      x: cell1.p.x + gutterX + columnWidth + x_pad,
      y: Q.height / 2 - rowHeight / 4 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    cell3 = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2 + x_pad,
      y: Q.height / 2 + rowHeight / 4 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    cell4 = stage.insert(new Q.UI.Container({
      x: cell1.p.x + gutterX + columnWidth + x_pad,
      y: Q.height / 2 + rowHeight / 2 + title.p.h,
      w: columnWidth,
      h: rowHeight
    }));
    
    // add 1 step
    numberpad = 40;
    row2offset = 30;
    step1text = cell1.insert(new Q.UI.Text({
      x: 0,
      y: -100,
      label: "Explore the graveyard",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: 30
    }));
    cell1.insert(new Q.UI.Text({
      x: step1text.p.x - step1text.p.w / 2 - numberpad,
      y: step1text.p.y,
      label: "1.",
      color: "#f2da38",
      family: "Boogaloo",
      size: 44
    }));
    cell1.insert(new Q.Sprite({
      x: step1text.p.x + step1text.p.w / 2 + 160,
      y: step1text.p.y - 15,
      sheet: "controls_eyegaze"
    }));
    // add 2 step
    step2text = cell2.insert(new Q.UI.Text({
      x: 0,
      y: step1text.p.y,
      label: "Find Healing Gun",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: 30
    }));
    cell2.insert(new Q.UI.Text({
      x: step2text.p.x - step2text.p.w / 2 - numberpad,
      y: step2text.p.y,
      label: "2.",
      color: "#f2da38",
      family: "Boogaloo",
      size: 44
    }));
    sprite = cell2.insert(new Q.Sprite({
      x: step2text.p.x + step2text.p.w / 2 + 120,
      y: step2text.p.y,
      sheet: "controls_gun"
    }));
    // add 3 step
    step3text = cell3.insert(new Q.UI.Text({
      x: step1text.p.x,
      y: step1text.p.y,
      label: "Shoot the zombies!",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: 30
    }));
    cell3.insert(new Q.UI.Text({
      x: step3text.p.x - step3text.p.w / 2 - numberpad,
      y: step3text.p.y,
      label: "3.",
      color: "#f2da38",
      family: "Boogaloo",
      size: 44
    }));
    cell3.insert(new Q.Sprite({
      x: step3text.p.x + step3text.p.w / 2 + 100,
      y: step3text.p.y,
      sheet: "controls_zombie"
    }));
    step4text = cell4.insert(new Q.UI.Text({
      x: step2text.p.x,
      y: step1text.p.y,
      label: "Find the exit",
      color: "#9ca2ae",
      family: "Boogaloo",
      size: 30
    }));
    cell4.insert(new Q.UI.Text({
      x: step4text.p.x - step4text.p.w / 2 - numberpad,
      y: step4text.p.y,
      label: "4.",
      color: "#f2da38",
      family: "Boogaloo",
      size: 44
    }));
    cell4.insert(new Q.Sprite({
      x: step4text.p.x + step4text.p.w / 2 + 120,
      y: step4text.p.y,
      sheet: "controls_door"
    }));
    // button
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height - marginY,
      w: Q.width / 2,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Give me some zombies",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    return button.on("click", function(e) {
      return Game.stageLevel(1);
    });
  });

  Q = Game.Q;

  Q.scene("end", function(stage) {
    var button, marginY;
    // some math
    marginY = Q.height * 0.25;
    // audio
    Q.AudioManager.stopAll();
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "The End",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 100
    }));
    // message
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 2,
      label: "You did it! \n\n You have completed the game, *and* unlocked some bonus levels. \n\n Hurrah!",
      color: "#c4da4a",
      family: "Boogaloo",
      size: 36,
      align: "center"
    }));
    // button
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height - marginY / 2,
      w: Q.width / 3,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Back to all levels",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    return button.on("click", function(e) {
      Game.stageLevelSelectScreen();
      return localStorage.setItem(Game.storageKeys.unlockedBonus, true);
    });
  });

  Q = Game.Q;

  Q.scene("gameOver", function(stage) {
    var buttonBack, buttonTryAgain, marginY, msg, offset_y, remaining_height, title, y_per_element;
    // some math
    marginY = Q.height * 0.25;
    // audio
    Q.AudioManager.stopAll();
    // add title
    title = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY,
      label: "Game Over",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 100
    }));
    // Split up rest of space equally
    offset_y = title.p.y / 2 + title.p.h / 2;
    remaining_height = Q.height - offset_y;
    y_per_element = remaining_height / 4;
    // message
    msg = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 2,
      label: "Oh no, you died!\nLooks like the zombies won't be healed today...",
      color: "#c4da4a",
      family: "Boogaloo",
      size: 36,
      align: "center"
    }));
    // button next
    buttonTryAgain = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Try again",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonTryAgain.p.x = Q.width / 2 + buttonTryAgain.p.w / 2 + 40;
    buttonTryAgain.on("click", function(e) {
      return Game.stageLevel(Q.state.get("currentLevel"));
    });
    // button back
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 70,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Main menu",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.p.x = Q.width / 2 - buttonBack.p.w / 2 - 40;
    return buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("gaze_overlay", function(stage) {
    var audioButton, base_width, btnJumpLeft, btnJumpRight, btnLeft, btnRight, btnShoot, button_points, camera_offset, createGazeButton, h, jump_xoffset, leftarrow_p, leftjump_normalised, leftjump_p, margin, marginBottomButtons, menuButton, onChangeHidden, onClick, onTouch, onTouchEnd, p, pauseButton, rightarrow_p, rightjump_normalised, rightjump_p, scale, shoot_p, shoot_points_normalised, stem_h, stem_start, stem_w, w, width, x_centre, x_left, x_right, y_lower, y_shoot, y_upper;
    scale = 1.0; // TODO: make this a setting
    base_width = Q.width / 10;
    width = base_width * scale;
    w = width;
    h = width;
    margin = w / 15;
    onClick = (action) => {
      return (e) => {
        if (action) {
          Q.inputs[action] = 1;
          return Q.input.trigger(action);
        }
      };
    };
    onTouch = (action) => {
      return (e) => {
        if (action) {
          return Q.inputs[action] = 1;
        }
      };
    };
    onTouchEnd = (action) => {
      return (e) => {
        if (action) {
          return Q.inputs[action] = 0;
        }
      };
    };
    // define some shapes for the main gaze controls  
    stem_h = h * .275; // varies height of arrow stem (from centre)
    stem_w = w * .05; // varies length of arrow stem (from centre)
    stem_start = w * 0.4; // varies how much stem is shrunk to balance the visual weight
    leftarrow_p = [[stem_start, -stem_h], [-stem_w, -stem_h], [-stem_w, -h / 2], [-w / 2, 0], [-stem_w, h / 2], [-stem_w, stem_h], [stem_start, stem_h]];
    rightarrow_p = [[-stem_start, stem_h], [stem_w, stem_h], [stem_w, h / 2], [+w / 2, 0], [stem_w, -h / 2], [stem_w, -stem_h], [-stem_start, -stem_h]];
    leftjump_normalised = [[0.5, 0.5], [0.5, 0.15], [0.428571428571429, -0.0714285714285714], [0.214285714285714, -0.321428571428571], [0.428571428571429, -0.5], [-0.5, -0.5], [-0.5, 0.321428571428571], [-0.321428571428571, 0.142857142857143], [-0.214285714285714, 0.25], [-0.214285714285714, 0.5]];
    rightjump_normalised = [[-0.5, 0.5], [-0.5, 0.15], [-0.428571428571429, -0.0714285714285714], [-0.214285714285714, -0.321428571428571], [-0.428571428571429, -0.5], [0.5, -0.5], [0.5, 0.321428571428571], [0.321428571428571, 0.142857142857143], [0.214285714285714, 0.25], [0.214285714285714, 0.5]];
    
    // (drew in inkscape, exported points)
    shoot_points_normalised = [[-0.55601, -0.06244], [-0.52346, 0.27963], [-0.39846, 0.42963], [-0.16236, 0.53631], [0.13835, 0.53221], [0.40483, 0.37777], [0.51227, 0.21024], [0.56227, 0.06024], [0.52017, -0.15927], [0.33858, -0.38187], [0.0781, -0.50214], [-0.21649, -0.44501], [-0.44801, -0.29167]];
    // scale shapes up
    shoot_p = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = shoot_points_normalised.length; j < len; j++) {
        p = shoot_points_normalised[j];
        results.push([p[0] * w * .9, p[1] * h * .9]);
      }
      return results;
    })();
    rightjump_p = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = rightjump_normalised.length; j < len; j++) {
        p = rightjump_normalised[j];
        results.push([p[0] * w * .9, p[1] * h * .9]);
      }
      return results;
    })();
    leftjump_p = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = leftjump_normalised.length; j < len; j++) {
        p = leftjump_normalised[j];
        results.push([p[0] * w * .9, p[1] * h * .9]);
      }
      return results;
    })();
    leftarrow_p = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = leftarrow_p.length; j < len; j++) {
        p = leftarrow_p[j];
        results.push([p[0] * 1.2, p[1] * 1.2]);
      }
      return results;
    })();
    rightarrow_p = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = rightarrow_p.length; j < len; j++) {
        p = rightarrow_p[j];
        results.push([p[0] * 1.2, p[1] * 1.2]);
      }
      return results;
    })();
    button_points = [leftjump_p, leftarrow_p, shoot_p, rightarrow_p, rightjump_p];
    
    // positioning
    // lower buttons (left, right, shoot) should centre vertically on platform player is stood on
    y_lower = Q.height / 2 + Game.assets.map.tileSize / 2;
    // shoot is even lower, to leave centre as rest position
    y_shoot = y_lower + Game.assets.map.tileSize * 1.5;
    // upper buttons (jump) centre just above next platform, for scale = 1, 
    y_upper = y_lower - (3 + scale) * Game.assets.map.tileSize;
    camera_offset = -0.4 * Game.assets.map.tileSize;
    x_left = Q.width / 2 + camera_offset - (width + margin * 2);
    x_right = Q.width / 2 + camera_offset + (width + margin * 2);
    x_centre = Q.width / 2 + camera_offset;
    // define button-adding function
    createGazeButton = (x, y, label, points, dwell_action, hover_action) => {
      var button;
      button = new Q.UI.PolygonButton({
        x: x,
        y: y,
        w: w,
        h: h,
        z: 1,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        fill: "#c4da4a50",
        radius: 10,
        fontColor: "#353b47",
        font: "400 58px Jolly Lodger",
        label: label,
        points: points
      });
      if (dwell_action) {
        button.on("click", onClick(dwell_action));
      } else {
        button.doDwell = false;
      }
      if (hover_action) {
        button.on("hover", onTouch(hover_action));
        button.on("touch", onTouch(hover_action));
        button.on("touchEnd", onTouchEnd(hover_action));
      }
      return button;
    };
    // we want direction+jump arrows to be left-aligned, not centre-aligned
    jump_xoffset = w / 30;
    btnLeft = createGazeButton(x_left, y_lower, "", leftarrow_p, "", "left");
    btnRight = createGazeButton(x_right, y_lower, "", rightarrow_p, "", "right");
    btnJumpLeft = createGazeButton(x_left + jump_xoffset, y_upper, "", leftjump_p, "jumpleft", "");
    btnJumpRight = createGazeButton(x_right - jump_xoffset, y_upper, "", rightjump_p, "jumpright", "");
    // shoot button has extra logic  
    btnShoot = createGazeButton(x_centre, y_shoot, "shoot", shoot_p, "fire", "");
    // unhide 'fire' button when we've got a gun
    onChangeHidden = (btn) => {
      return () => {
        return btn.p.hidden = !Q.state.get("hasGun");
      };
    };
    btnShoot.p.hidden = !Q.state.get("hasGun");
    Q.state.on("change.hasGun", onChangeHidden(btnShoot));
    // Add everything to the stage
    stage.insert(btnLeft);
    stage.insert(btnRight);
    stage.insert(btnJumpLeft);
    stage.insert(btnJumpRight);
    stage.insert(btnShoot);
    // Bottom buttons
    marginBottomButtons = Q.height * 0.1;
    pauseButton = stage.insert(new Q.UI.PauseButton({
      x: Q.width / 2,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
    menuButton = stage.insert(new Q.UI.MenuButton({
      x: Q.width - marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
    return audioButton = stage.insert(new Q.UI.AudioButton({
      x: marginBottomButtons,
      y: Q.height - marginBottomButtons,
      isSmall: false
    }));
  });

  Q = Game.Q;

  Q.scene("hud", function(stage) {
    var bulletsContainer, bulletsImg, enemiesContainer, healthContainer, healthImg, infoContainer, keyContainer, keyImg, playerAvatar;
    // stage.insert new Q.UI.RadialGradient()
    stage.insert(new Q.UI.LinearGradient());
    // doctor's comments
    Game.playerAvatar = playerAvatar = stage.insert(new Q.UI.PlayerAvatar({
      z: 10
    }));
    infoContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#fff"
    }));
    Game.infoLabel = infoContainer.insert(new Q.UI.InfoLabel({
      container: infoContainer,
      offsetLeft: playerAvatar.p.w
    }));
    // enemies counter
    enemiesContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    enemiesContainer.insert(new Q.UI.EnemiesCounter());
    enemiesContainer.fit(0, 8);
    enemiesContainer.p.x = Q.width - enemiesContainer.p.w / 2 - 60;
    stage.insert(new Q.UI.EnemiesAvatar({
      z: 12
    }));
    // bullets counter
    bulletsContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    bulletsImg = bulletsContainer.insert(new Q.UI.BulletsImg());
    bulletsContainer.insert(new Q.UI.BulletsCounter({
      img: bulletsImg.p
    }));
    bulletsContainer.fit(0, 8);
    bulletsContainer.p.x = enemiesContainer.p.x - enemiesContainer.p.w / 2 - bulletsContainer.p.w / 2 - 20 + 30;
    // health counter
    healthContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    Game.healthImg = healthImg = healthContainer.insert(new Q.UI.HealthImg());
    healthContainer.insert(new Q.UI.HealthCounter({
      img: healthImg.p
    }));
    healthContainer.fit(0, 8);
    healthContainer.p.x = bulletsContainer.p.x - bulletsContainer.p.w / 2 - healthContainer.p.w / 2 - 20;
    // inventory key
    keyContainer = stage.insert(new Q.UI.Container({
      y: 40,
      z: 10,
      fill: "#232322"
    }));
    keyImg = keyContainer.insert(new Q.UI.InventoryKey());
    keyContainer.fit(5, 8);
    return keyContainer.p.x = healthContainer.p.x - healthContainer.p.w / 2 - keyContainer.p.w / 2 - 34;
  });

  Q = Game.Q;

  Q.scene("levelSelectMore", function(stage) {
    var aboutButton, arrow, audioButton, authors, bonusUnlocked, button, columnInP, columnWidth, columnsNo, container, cursorButton, enabled, fontsize, gutterX, gutterXinP, gutterY, gutterYinP, h, i, item, j, l, len, level, level_name, m, marginX, marginXinP, marginY, marginYinP, menuButton, name_width, pauseButton, ref, ref1, rowHeight, stars, starsX, starsY, w, x, x_sep, y;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // layout params
    marginXinP = 20; // %
    marginYinP = 20; // %
    gutterXinP = 8; // %
    gutterYinP = 14; // %
    columnsNo = 4;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    marginY = Q.height * marginYinP * 0.01;
    gutterY = Q.height * gutterYinP * 0.01;
    rowHeight = Q.height * 0.22; // 22%
    
    // init params
    x = marginX + columnWidth / 2;
    y = marginY + rowHeight / 2;
    w = columnWidth;
    h = rowHeight;
    // prepare special buttons for first column

    // add level buttons
    bonusUnlocked = localStorage.getItem(Game.storageKeys.unlockedBonus);
    for (item = j = 0; j <= 6; item = ++j) {
      if (item % columnsNo === 0) {
        x = marginX + columnWidth / 2;
        if (item > 0) {
          y += rowHeight + gutterY;
        }
      }
      // put button into container
      container = stage.insert(new Q.UI.Container({
        x: x,
        y: y
      }));
      x += columnWidth + gutterX;
      if (item === 0) { // previous button  
        enabled = Game.moreLevelsPage > 0;
        arrow = container.insert(new Q.UI.ArrowButton({
          x: 0,
          y: 0,
          w: w,
          h: h,
          flip: "x",
          page: Game.moreLevelsPage - 1,
          enabled: enabled
        }, fontsize = 32));
        container.insert(new Q.UI.Text({
          x: 10,
          y: -arrow.p.h / 8,
          label: "Previous",
          color: "#404444",
          family: "Jolly Lodger",
          size: fontsize
        }));
      } else if (item === 3) { // next button
        arrow = container.insert(new Q.UI.ArrowButton({
          x: 0,
          y: 0,
          w: w,
          h: h,
          page: Game.moreLevelsPage + 1,
          enabled: Game.moreLevelsPage > 0
        }, fontsize = 32));
        container.insert(new Q.UI.Text({
          x: -10,
          y: -arrow.p.h / 8,
          label: "Next",
          color: "#404444",
          family: "Jolly Lodger",
          size: fontsize
        }));
      } else if (item === 4) {
        // Pause button bottom left
        pauseButton = container.insert(new Q.UI.PauseButton({
          x: 0,
          y: 0,
          isSmall: false
        }));
      } else {
        // work out level number
        level = item + 5 + Game.moreLevelsPage * 4;
        if (item > 3) {
          level = level - 2;
        }
        if (level < Game.levels_array.length) {
          button = new Q.UI.LevelButton({
            level: level,
            x: 0,
            y: 0,
            w: w,
            h: h,
            enabled: true
          });
          container.insert(button);
          
          // add label if level has name
          // ugh, there's a bit of confusion here with off-by-one indexing
          level_name = Game.levels_array[level].name;
          if (level_name) {
            fontsize = 28;
            Q.ctx.font = "400 " + fontsize + "px Jolly Lodger";
            name_width = Q.ctx.measureText(level_name).width;
            // background panel
            container.insert(new Q.UI.Container({
              x: 0,
              y: button.p.h * .5 - fontsize * 0.05,
              w: name_width * 1.25,
              h: fontsize * 1.1,
              radius: 2,
              fill: "#81879377",
              type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
            }));
            // foreground text
            container.insert(new Q.UI.Text({
              x: 0,
              y: button.p.h * .5,
              label: level_name,
              color: "#000000",
              family: "Jolly Lodger",
              size: fontsize
            }));
          }
          
          // add progress stars#          
          if (item > 0) {
            stars = localStorage.getItem(Game.storageKeys.levelProgress + ":" + level);
          }
          if (stars) {
            starsX = -60;
            starsY = [34, 50, 40];
            for (i = l = 1, ref = stars; (1 <= ref ? l <= ref : l >= ref); i = 1 <= ref ? ++l : --l) {
              container.insert(new Q.UI.LevelScoreImgSmall({
                x: starsX,
                y: starsY[i - 1]
              }));
              starsX += 60;
            }
          }
        }
      }
    }
    // end of adding level buttons

    // Back button bottom right
    menuButton = stage.insert(new Q.UI.MenuButton({
      x: x,
      y: y,
      isSmall: false
    }));
    // separator bars
    x_sep = marginX + columnWidth + gutterX / 2;
    ref1 = [x_sep, Q.width - x_sep];
    for (m = 0, len = ref1.length; m < len; m++) {
      x = ref1[m];
      stage.insert(new Q.UI.Container({
        x: x,
        y: Q.height / 2,
        w: 10,
        h: Q.height * 0.65,
        fill: "#81879366",
        radius: 8,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
    }
    // background
    stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2,
      w: x_sep + 5,
      h: Q.height * 0.65,
      fill: "#81879333",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Bonus levels!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 60
    }));
    // authors
    authors = stage.insert(new Q.UI.Authors());
    // audio button
    audioButton = stage.insert(new Q.UI.AudioButton({
      y: marginY / 2
    }));
    cursorButton = stage.insert(new Q.UI.CursorButton({
      y: marginY / 2
    }));
    
    // about button
    aboutButton = stage.insert(new Q.UI.Button({
      y: marginY / 2,
      label: "About",
      fill: "#818793",
      radius: 10,
      fontColor: "#404444",
      font: "400 32px Jolly Lodger",
      z: 100,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    aboutButton.on("click", function(e) {
      return console.log('About!');
    });
    aboutButton.p.x = marginX + aboutButton.p.w / 2;
    audioButton.p.x = Q.width - marginX - audioButton.p.w / 2;
    return cursorButton.p.x = Q.width - marginX - audioButton.p.w - cursorButton.p.w;
  });

  Q = Game.Q;

  Q.scene("levelSelect", function(stage) {
    var aboutButton, audioButton, authors, bonus, bonusUnlocked, columnInP, columnWidth, columnsNo, container, cursorButton, enabled, fontsize, gutterX, gutterXinP, gutterY, gutterYinP, h, i, item, j, l, level, marginX, marginXinP, marginY, marginYinP, ref, rowHeight, settings, settings_label, stars, starsX, starsY, w, x, y;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // layout params
    marginXinP = 20; // %
    marginYinP = 20; // %
    gutterXinP = 8; // %
    gutterYinP = 14; // %
    columnsNo = 4;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    marginY = Q.height * marginYinP * 0.01;
    gutterY = Q.height * gutterYinP * 0.01;
    rowHeight = Q.height * 0.22; // 22%
    
    // init params
    x = marginX + columnWidth / 2;
    y = marginY + rowHeight / 2;
    w = columnWidth;
    h = rowHeight;
    // prepare special buttons for first column

    // add level buttons
    bonusUnlocked = true; //localStorage.getItem(Game.storageKeys.unlockedBonus)
    for (item = j = 0; j <= 6; item = ++j) {
      if (item % columnsNo === 0) {
        x = marginX + columnWidth / 2;
        if (item > 0) {
          y += rowHeight + gutterY;
        }
      }
      enabled = item <= Game.availableLevel ? true : false;
      // put button into container
      container = stage.insert(new Q.UI.Container({
        x: x,
        y: y
      }));
      x += columnWidth + gutterX;
      // If we've unlocked levels, we'll replace L6 with a link to "more levels"
      if (item === 6 && bonusUnlocked) {
        break;
      }
      container.insert(new Q.UI.LevelButton({
        level: item,
        x: 0,
        y: 0,
        w: w,
        h: h,
        enabled: enabled
      }));
      // Add label for tutorial
      if (item === 0) {
        container.insert(new Q.UI.Text({
          x: 0,
          y: 0,
          label: "Tutorial",
          color: "#404444",
          family: "Jolly Lodger",
          size: 32
        }));
      }
      // add progress stars
      level = item;
      if (item > 0) {
        stars = localStorage.getItem(Game.storageKeys.levelProgress + ":" + level);
      }
      if (stars) {
        starsX = -60;
        starsY = [34, 50, 40];
        for (i = l = 1, ref = stars; (1 <= ref ? l <= ref : l >= ref); i = 1 <= ref ? ++l : --l) {
          container.insert(new Q.UI.LevelScoreImgSmall({
            x: starsX,
            y: starsY[i - 1]
          }));
          starsX += 60;
        }
      }
    }
    // end of adding level buttons

    // "More levels!" if unlocked
    if (bonusUnlocked) {
      bonus = container.insert(new Q.UI.MoreLevelsButton({
        x: 0,
        y: 0,
        w: w,
        h: h
      }));
      fontsize = 32;
      container.insert(new Q.UI.Text({
        x: 0,
        y: -fontsize / 2,
        label: "Extra",
        color: "#404444",
        family: "Jolly Lodger",
        size: fontsize
      }));
      container.insert(new Q.UI.Text({
        x: 0,
        y: fontsize / 2,
        label: "levels",
        color: "#404444",
        family: "Jolly Lodger",
        size: fontsize
      }));
    }
    // settings button bottom right
    container = stage.insert(new Q.UI.Container({
      x: x,
      y: y
    }));
    settings = container.insert(new Q.UI.SettingsButton({
      x: 0,
      y: 0,
      w: w,
      h: h
    }));
    settings_label = container.insert(new Q.UI.Text({
      x: 0,
      y: settings.p.h / 6,
      label: "Settings",
      color: "#404444",
      family: "Jolly Lodger",
      size: 32
    }));
    container.insert(new Q.Sprite({
      x: 2,
      y: settings_label.p.y - settings_label.p.h - 15,
      sheet: "settings_button"
    }));
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Everything begins here!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 60
    }));
    // authors
    authors = stage.insert(new Q.UI.Authors());
    // audio button
    audioButton = stage.insert(new Q.UI.AudioButton({
      y: marginY / 2
    }));
    cursorButton = stage.insert(new Q.UI.CursorButton({
      y: marginY / 2
    }));
    
    // about button
    aboutButton = stage.insert(new Q.UI.Button({
      y: marginY / 2,
      label: "About",
      fill: "#818793",
      radius: 10,
      fontColor: "#404444",
      font: "400 32px Jolly Lodger",
      z: 100,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    aboutButton.on("click", function(e) {
      return Game.stageScreen("about");
    });
    aboutButton.p.x = marginX + aboutButton.p.w / 2;
    audioButton.p.x = Q.width - marginX - audioButton.p.w / 2;
    return cursorButton.p.x = Q.width - marginX - audioButton.p.w - cursorButton.p.w;
  });

  Q = Game.Q;

  Q.scene("levelSummary", function(stage) {
    var buttonBack, buttonNext, columnInP, columnWidth, columnsNo, empty, gutterX, gutterXinP, index, j, lineHeight, marginX, marginXinP, marginY, performance, previousStars, score, scoreImg, stars, starsContainer, summaryContainer, x;
    // some math
    marginY = Q.height * 0.25;
    marginXinP = 20; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    // audio
    Q.AudioManager.stopAll();
    // add title
    stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY * .75,
      label: "Well done!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 100
    }));
    // add level summary
    summaryContainer = stage.insert(new Q.UI.Container({
      x: marginX + columnWidth / 2,
      y: Q.height / 2
    }));
    lineHeight = 50;
    if (stage.options.health) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: -lineHeight * 2,
        label: "Health collected: " + stage.options.health.collected + "/" + stage.options.health.available,
        color: "#c4da4a",
        family: "Boogaloo",
        size: 36
      }));
    }
    if (stage.options.zombies) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: -lineHeight,
        label: "Zombies healed: " + stage.options.zombies.healed + "/" + stage.options.zombies.available,
        color: "#c4da4a",
        family: "Boogaloo",
        size: 36
      }));
    }
    if (stage.options.bullets) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: 0,
        label: "Bullets wasted: " + stage.options.bullets.waisted + "/" + stage.options.bullets.available,
        color: "#c4da4a",
        family: "Boogaloo",
        size: 36
      }));
    }
    if (stage.options.zombieModeFound != null) {
      summaryContainer.insert(new Q.UI.Text({
        x: 0,
        y: lineHeight,
        label: "Zombie Mode: " + (stage.options.zombieModeFound ? "done" : "not found"),
        color: "#c4da4a",
        family: "Boogaloo",
        size: 36
      }));
    }
    // button next
    buttonNext = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 70,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Play next",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonNext.p.x = Q.width / 2 + buttonNext.p.w / 2 + 40;
    buttonNext.on("click", function(e) {
      // last level just finished
      if (Q.state.get("currentLevel") === 6) {
        Game.stageEndScreen();
        return;
      }
      return Game.stageLevel(Q.state.get("currentLevel") + 1);
    });
    // button back
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: 70,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Main menu",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.p.x = Q.width / 2 - buttonBack.p.w / 2 - 40;
    buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
    // save progress in game
    if (Q.state.get("currentLevel") >= Game.availableLevel) {
      Game.availableLevel = Q.state.get("currentLevel") + 1;
      localStorage.setItem(Game.storageKeys.availableLevel, Game.availableLevel);
    }
    // count stars
    score = stage.options.zombies.healed / stage.options.zombies.available;
    stars = 0;
    performance = "";
    if (score <= 0.5) {
      stars = 1;
      performance = "Okay";
    } else if (score > 0.5 && score < 0.9) {
      stars = 2;
      performance = "Good";
    } else {
      stars = 3;
      performance = "Perfect!";
    }
    // save only if better than previous
    previousStars = localStorage.getItem(Game.storageKeys.levelProgress + ":" + Q.state.get("currentLevel"));
    if (previousStars < stars) {
      localStorage.setItem(Game.storageKeys.levelProgress + ":" + Q.state.get("currentLevel"), stars);
    }
    // insert stars on the screen
    starsContainer = stage.insert(new Q.UI.Container({
      x: summaryContainer.p.x + gutterX + columnWidth,
      y: Q.height / 2
    }));
    x = -80 - 20; // width of LevelScoreImg - margin between stars
    for (index = j = 1; j <= 3; index = ++j) {
      empty = stars >= index ? false : true;
      scoreImg = starsContainer.insert(new Q.UI.LevelScoreImg({
        x: x,
        y: -lineHeight / 2,
        empty: empty
      }));
      x += scoreImg.p.w + 20;
    }
    // Score:
    stage.insert(new Q.UI.Text({
      x: starsContainer.p.x,
      y: starsContainer.p.y + scoreImg.p.h * 0.6,
      label: "Score: " + performance,
      color: "#ffffff",
      family: "Boogaloo",
      size: 36
    }));
    // track events
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "score", score);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "stars", stars);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombie Mode", stage.options.zombieModeFound);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Health collected", stage.options.health.collected + "/" + stage.options.health.available);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombies healed", stage.options.zombies.healed + "/" + stage.options.zombies.available);
    return Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Bullets wasted", stage.options.bullets.waisted + "/" + stage.options.bullets.available);
  });

  Q = Game.Q;

  Q.scene("settingsPlaceholder", function(stage) {
    var authors, button, buttonTextSize, desc, description, label, title, titleContainer, y_pad;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    // description = "Imagine, what if the cure exists?\n"
    description = "This will be a settings page\n";
    description += "...including...\n";
    description += "\n";
    description += "- dwell/click settings\n";
    description += "- Sizing of game UI\n";
    description += "- difficulty, including hard-core and god mode \n";
    description += "- more settings for music / sounds / narration\n";
    // TODO link to https://raw.githubusercontent.com/cykod/Quintus/master/MIT-LICENSE.txt
    // probably a link to github where we can more easily detail things / give links
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#000000",
      family: "Jolly Lodger",
      size: 36
    }));
    // panel
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: desc.p.w * 1.1,
      h: desc.p.h * 1.1,
      z: desc.p.z - 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: desc.p.y - desc.p.h / 2,
      label: "Settings",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 90
    }));
    title.p.y = title.p.y - title.p.h / 2 - y_pad;
    title.size();
    // button
    label = "Back";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: desc.p.y + desc.p.h / 2,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.p.y = button.p.y + button.p.h / 2 + y_pad * 2;
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("start", function(stage) {
    var authors, button, buttonTextSize, desc, description, label, title, titleContainer, y_pad;
    // add title
    y_pad = Q.height / 20;
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    // description = "Imagine, what if the cure exists?\n"
    description = "You have found the cure for the zombie plague!\n\n";
    description += "Explore an old, abandoned graveyard,\n";
    description += "heal as many zombies as you can,\n";
    description += "and find your way out.\n\n";
    description += "But be careful not to become one of them!";
    desc = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: 0,
      align: 'center',
      label: description,
      color: "#000000",
      family: "Jolly Lodger",
      size: 36
    }));
    // panel
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: desc.p.w * 1.1,
      h: desc.p.h * 1.1,
      z: desc.p.z - 1,
      fill: "#e3ecf933",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    title = titleContainer.insert(new Q.UI.Text({
      x: 0,
      y: desc.p.y - desc.p.h / 2,
      label: "Heal'em All",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 90
    }));
    title.p.y = title.p.y - title.p.h / 2 - y_pad;
    title.size();
    // button
    label = "Continue";
    buttonTextSize = Q.ctx.measureText(label);
    button = titleContainer.insert(new Q.UI.Button({
      x: 0,
      y: desc.p.y + desc.p.h / 2,
      w: buttonTextSize.width * 1.3,
      h: 80,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.p.y = button.p.y + button.p.h / 2 + y_pad * 2;
    titleContainer.fit();
    // authors
    authors = stage.insert(new Q.UI.Authors());
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  Q = Game.Q;

  Q.scene("tutorial", function(stage) {
    var background, bullets_per_gun, data_asset, enemies, ignore_objects, j, len, objects, text_props, texts, yFudge;
    data_asset = Game.assets.tutorial.dataAsset;
    bullets_per_gun = 20;
    // main map with collision
    Game.map = Q.LevelParser.load_map(data_asset, Game.SPRITE_TILES, 0);
    stage.collisionLayer(Game.map);
    
    // background decorations
    background = Q.LevelParser.load_map(data_asset, Game.SPRITE_NONE, 1);
    stage.insert(background);
    // all other objects, except zombie, which will be special for tutorial
    ignore_objects = ["Zombie"];
    objects = Q.LevelParser.parse_objects(data_asset, ignore_objects);
    Q.LevelParser.load_objects(stage, objects, bullets_per_gun);
    // Add zombie manually
    enemies = [
      [
        "Zombie",
        Q.tilePos(72,
        14,
        {
          canFallOff: false
        })
      ]
    ];
    stage.loadAssets(enemies);
    // store level data for level summary
    Game.currentLevelData.health.available = stage.lists.Heart.length;
    Game.currentLevelData.zombies.available = stage.lists.Zombie.length;
    // Add help texts
    yFudge = 1.75;
    texts = [
      Q.tilePos(38,
      8 + yFudge,
      {
        label: "Look at the left and right arrows below to walk"
      }),
      Q.tilePos(46,
      11 + yFudge,
      {
        label: "The longer you look, the faster you'll walk"
      }),
      Q.tilePos(54,
      11 + yFudge,
      {
        label: "Dwell on a jump button to jump sideways"
      }),
      Q.tilePos(64.5,
      9 + yFudge,
      {
        label: "Try jumping over the gap"
      }),
      Q.tilePos(73 - 1.5,
      9 + yFudge,
      {
        label: "Watch out for zombies!"
      }),
      Q.tilePos(77,
      11 + yFudge,
      {
        label: "Try to get past without being bitten"
      }),
      Q.tilePos(83,
      10.5 + yFudge,
      {
        label: "Collect the healing gun,"
      }),
      Q.tilePos(83,
      11 + yFudge,
      {
        label: "and fire at the zombie"
      }),
      Q.tilePos(88,
      9 + yFudge,
      {
        label: "Health packs give you an extra life -->"
      }),
      Q.tilePos(92,
      13 + yFudge,
      {
        label: "To complete the level,"
      }),
      Q.tilePos(92,
      13.5 + yFudge,
      {
        label: "find the key and exit"
      })
    ];
    for (j = 0, len = texts.length; j < len; j++) {
      text_props = texts[j];
      stage.insert(new Q.UI.HelpText(text_props));
    }
    
    // # store level data for level summary
    Game.currentLevelData.health.available = stage.lists.Heart.length;
    return Game.currentLevelData.zombies.available = stage.lists.Zombie.length;
  });

  Q = Game.Q;

  Q.scene("tutorialSummary", function(stage) {
    var buttonBack, buttonHeight, buttonNext, buttonStart, columnInP, columnWidth, columnsNo, empty, gutterX, gutterXinP, index, j, marginX, marginXinP, marginY, msg, msgLabel, previousStars, score, scoreImg, stars, starsContainer, title, x;
    // some math
    marginY = Q.height * 0.25;
    buttonHeight = 80;
    marginXinP = 20; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    // layout math
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    // audio
    Q.AudioManager.stopAll();
    // add title
    title = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: marginY / 2,
      label: "Well done!",
      color: "#f2da38",
      family: "Jolly Lodger",
      size: 100
    }));
    msgLabel = "You have successfully completed the tutorial\n";
    if (stage.options.zombies) {
      msgLabel += "Zombies healed: " + stage.options.zombies.healed + "/" + stage.options.zombies.available + "\n";
    }
    msgLabel += "Are you feeling ready to play for real?";
    // message
    msg = stage.insert(new Q.UI.Text({
      x: Q.width / 2,
      y: Q.height / 4 + marginY / 4,
      label: msgLabel,
      color: "#c4da4a",
      family: "Boogaloo",
      size: 36,
      align: "center"
    }));
    // start main game:
    buttonStart = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height / 2,
      w: Q.width / 4,
      h: buttonHeight,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Start game",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonStart.on("click", function(e) {
      return Game.stageScreen("controls");
    });
    // button next
    buttonNext = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: buttonHeight,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Try again",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonNext.p.x = Q.width / 2 + buttonNext.p.w / 2 + 40;
    buttonNext.on("click", function(e) {
      return Game.stageLevel(Q.state.get("currentLevel"));
    });
    // button back
    buttonBack = stage.insert(new Q.UI.Button({
      y: Q.height - marginY,
      w: Q.width / 4,
      h: buttonHeight,
      fill: "#f2da38",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: "Main menu",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    buttonBack.p.x = Q.width / 2 - buttonBack.p.w / 2 - 40;
    buttonBack.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
    // save progress in game
    if (Q.state.get("currentLevel") >= Game.availableLevel) {
      Game.availableLevel = Q.state.get("currentLevel") + 1;
      localStorage.setItem(Game.storageKeys.availableLevel, Game.availableLevel);
    }
    // count stars
    score = stage.options.zombies.healed / stage.options.zombies.available;
    stars = 0;
    if (score <= 0.5) {
      stars = 1;
    } else if (score > 0.5 && score < 0.9) {
      stars = 2;
    } else {
      stars = 3;
    }
    // save only if better than previous
    previousStars = localStorage.getItem(Game.storageKeys.levelProgress + ":" + Q.state.get("currentLevel"));
    if (previousStars < stars) {
      localStorage.setItem(Game.storageKeys.levelProgress + ":" + Q.state.get("currentLevel"), stars);
    }
    // insert stars on the screen
    starsContainer = stage.insert(new Q.UI.Container({
      x: summaryContainer.p.x + gutterX + columnWidth,
      y: Q.height / 2
    }));
    x = -80 - 20; // width of LevelScoreImg - margin between stars
    for (index = j = 1; j <= 3; index = ++j) {
      empty = stars >= index ? false : true;
      scoreImg = starsContainer.insert(new Q.UI.LevelScoreImg({
        x: x,
        y: -lineHeight / 2,
        empty: empty
      }));
      x += scoreImg.p.w + 20;
    }
    // track events
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "score", score);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "stars", stars);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombie Mode", stage.options.zombieModeFound);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Health collected", stage.options.health.collected + "/" + stage.options.health.available);
    Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Zombies healed", stage.options.zombies.healed + "/" + stage.options.zombies.available);
    return Game.trackEvent("levelSummary:" + Q.state.get("currentLevel"), "Bullets wasted", stage.options.bullets.waisted + "/" + stage.options.bullets.available);
  });

  Q = Game.Q;

  Q.scene("controls_settings", function(stage) {
    var button, buttonTextSize, cellsize, columnInP, columnWidth, columnsNo, container_bottomleft, container_bottomright, container_topleft, container_topright, gutterX, gutterXinP, label, marginX, marginXinP, marginY, pad, rowHeight, titleContainer, x_pad;
    // audio
    Q.AudioManager.stopAll();
    Q.AudioManager.clear();
    // some math
    titleContainer = stage.insert(new Q.UI.Container({
      x: Q.width / 2,
      y: Q.height / 2
    }));
    // vertical divider in center
    titleContainer.insert(new Q.UI.Container({
      x: 0,
      y: 0,
      w: 10,
      h: Q.height * 0.65,
      fill: "#2a2f38",
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // headings
    titleContainer.insert(new Q.UI.Text({
      x: -Q.width / 4,
      y: -Q.height * .4,
      family: "Jolly Lodger",
      size: 40,
      label: "SELECTION METHOD",
      fill: "#353b47",
      radius: 10,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    titleContainer.insert(new Q.UI.Text({
      x: Q.width / 4,
      y: -Q.height * .4,
      label: "APPEARANCE",
      family: "Jolly Lodger",
      size: 40,
      fill: "#353b47",
      radius: 10,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // layout math
    marginY = Q.height * 0.15;
    marginXinP = 10; // %
    gutterXinP = 8; // %
    columnsNo = 2;
    columnInP = (100 - (marginXinP * 2) - (columnsNo - 1) * gutterXinP) / columnsNo; // 24%
    marginX = Q.width * marginXinP * 0.01;
    gutterX = Q.width * gutterXinP * 0.01;
    columnWidth = Q.width * columnInP * 0.01;
    rowHeight = Q.height * 0.3;
    x_pad = 10;
    // Add containers for diff settings
    // Each one will contain three cells, e.g. [-] [label] [+]
    container_topleft = titleContainer.insert(new Q.UI.Container({
      x: -(marginX / 2 + columnWidth / 2),
      y: -(rowHeight / 2 + marginY / 4),
      w: columnWidth,
      h: rowHeight,
      fill: "#2a2f38",
      opacity: 0.8,
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    container_bottomleft = titleContainer.insert(new Q.UI.Container({
      x: -(marginX / 2 + columnWidth / 2),
      y: +(rowHeight / 2 + marginY / 4),
      w: columnWidth,
      h: rowHeight,
      fill: "#2a2f38",
      opacity: 0.8,
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    container_topright = titleContainer.insert(new Q.UI.Container({
      x: +(marginX / 2 + columnWidth / 2),
      y: -(rowHeight / 2 + marginY / 4),
      w: columnWidth,
      h: rowHeight,
      fill: "#2a2f38",
      opacity: 0.8,
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    container_bottomright = titleContainer.insert(new Q.UI.Container({
      x: +(marginX / 2 + columnWidth / 2),
      y: +(rowHeight / 2 + marginY / 4),
      w: columnWidth,
      h: rowHeight,
      fill: "#2a2f38",
      opacity: 0.8,
      radius: 8,
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    // more math
    cellsize = container_topleft.p.w / 4;
    pad = 10;
    // Click method
    container_topleft.insert(new Q.UI.PolygonButton({
      fill: "#c4da4a",
      x: -(cellsize + pad),
      w: cellsize,
      h: cellsize,
      radius: 10,
      height: 60,
      fontColor: "#353b47",
      font: "400 40px Jolly Lodger",
      label: "Dwell Click",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
      points: [[0, 90], [-60, -50], [85, 0], [-70, 60], [30, -90]]
    }));
    stage.insert(new Q.UI.Button({
      x: +(cellsize + pad),
      fill: "#c4da4a",
      w: cellsize,
      h: cellsize,
      radius: 10,
      height: 60,
      fontColor: "#353b47",
      font: "400 40px Jolly Lodger",
      label: "Own Click",
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
      z: 100
    }));
    container_topleft.on("click", function(e) {
      return console.log('wibble');
    });
    // button
    label = "Back";
    buttonTextSize = Q.ctx.measureText(label);
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height * 0.9,
      fill: "#c4da4a",
      w: buttonTextSize * 1.2,
      radius: 10,
      height: 60,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
    Q.Adjuster.add(stage, Q.width / 2, Q.height / 2 + 150, 400, 200, 'UI scale', 'uiScale');
    Q.Adjuster.add(stage, Q.width / 2, Q.height / 2 - 150, 400, 200, 'Dwell time', 'dwellTime');
    Q.Adjuster.add(stage, Q.width / 2, Q.height / 2, 400, 200, 'UI scale', 'uiScale');
    // button
    label = "Preview controls";
    buttonTextSize = Q.ctx.measureText(label);
    button = stage.insert(new Q.UI.Button({
      x: Q.width / 2,
      y: Q.height * 0.1,
      w: buttonTextSize * 1.6,
      fill: "#c4da4a",
      radius: 10,
      fontColor: "#353b47",
      font: "400 58px Jolly Lodger",
      height: 60,
      label: label,
      keyActionName: "confirm",
      type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
    }));
    return button.on("click", function(e) {
      return Game.stageLevelSelectScreen();
    });
  });

  // # add cells, 2x2
  // x_pad = -50 # to account for images on right of centralised text

  // cell1 = stage.insert new Q.UI.Container
  //   x: marginX + columnWidth/2 + x_pad
  //   y: Q.height/2 - rowHeight/2 + title.p.h
  //   w: columnWidth
  //   h: rowHeight

  // cell2 = stage.insert new Q.UI.Container
  //   x: cell1.p.x + gutterX + columnWidth + x_pad 
  //   y: Q.height/2 - rowHeight/4 + title.p.h
  //   w: columnWidth
  //   h: rowHeight

  // cell3 = stage.insert new Q.UI.Container
  //   x: marginX + columnWidth/2 + x_pad 
  //   y: Q.height/2 + rowHeight/4 + title.p.h
  //   w: columnWidth
  //   h: rowHeight

  // cell4 = stage.insert new Q.UI.Container
  //   x: cell1.p.x + gutterX + columnWidth + x_pad 
  //   y: Q.height/2 + rowHeight/2 + title.p.h
  //   w: columnWidth
  //   h: rowHeight

  // # add 1 step
  // numberpad = 40
  // row2offset = 30

  // step1text = cell1.insert new Q.UI.Text
  //   x: 0
  //   y: -100
  //   label: "Explore the graveyard"
  //   color: "#9ca2ae"
  //   family: "Boogaloo"
  //   size: 30

  // cell1.insert new Q.UI.Text
  //   x: step1text.p.x - step1text.p.w/2 - numberpad
  //   y: step1text.p.y
  //   label: "1."
  //   color: "#f2da38"
  //   family: "Boogaloo"
  //   size: 44

  // cell1.insert new Q.Sprite
  //   x: step1text.p.x + step1text.p.w/2 + 160 
  //   y: step1text.p.y  - 15
  //   sheet: "controls_eyegaze"

  // # add 2 step
  // step2text = cell2.insert new Q.UI.Text
  //   x: 0
  //   y: step1text.p.y
  //   label: "Find Healing Gun"
  //   color: "#9ca2ae"
  //   family: "Boogaloo"
  //   size: 30

  // cell2.insert new Q.UI.Text
  //   x: step2text.p.x - step2text.p.w/2 - numberpad 
  //   y: step2text.p.y
  //   label: "2."
  //   color: "#f2da38"
  //   family: "Boogaloo"
  //   size: 44

  // sprite = cell2.insert new Q.Sprite
  //   x: step2text.p.x + step2text.p.w/2 + 120 
  //   y: step2text.p.y
  //   sheet: "controls_gun"

  // # add 3 step

  // step3text = cell3.insert new Q.UI.Text
  //   x: step1text.p.x
  //   y: step1text.p.y
  //   label: "Shoot the zombies!"
  //   color: "#9ca2ae"
  //   family: "Boogaloo"
  //   size: 30

  // cell3.insert new Q.UI.Text
  //   x: step3text.p.x - step3text.p.w/2 - numberpad 
  //   y: step3text.p.y
  //   label: "3."
  //   color: "#f2da38"
  //   family: "Boogaloo"
  //   size: 44

  // cell3.insert new Q.Sprite
  //   x: step3text.p.x + step3text.p.w/2 + 100 
  //   y: step3text.p.y
  //   sheet: "controls_zombie"

  // step4text = cell4.insert new Q.UI.Text
  //   x: step2text.p.x
  //   y: step1text.p.y
  //   label: "Find the exit"
  //   color: "#9ca2ae"
  //   family: "Boogaloo"
  //   size: 30

  // cell4.insert new Q.UI.Text
  //   x: step4text.p.x - step4text.p.w/2 - numberpad 
  //   y: step4text.p.y
  //   label: "4."
  //   color: "#f2da38"
  //   family: "Boogaloo"
  //   size: 44

  // cell4.insert new Q.Sprite
  //   x: step4text.p.x + step4text.p.w/2 + 120 
  //   y: step4text.p.y
  //   sheet: "controls_door"

  // # button
  // button = stage.insert new Q.UI.Button
  //   x: Q.width/2
  //   y: Q.height - marginY
  //   w: Q.width/2
  //   h: 70
  //   fill: "#c4da4a"
  //   radius: 10
  //   fontColor: "#353b47"
  //   font: "400 58px Jolly Lodger"
  //   label: "Give me some zombies"
  //   keyActionName: "confirm"
  //   type: Q.SPRITE_UI | Q.SPRITE_DEFAULT

  // button.on "click", (e) ->
  //   Game.stageLevel(1)
  Q = Game.Q;

  Q.Sprite.extend('Background', {
    init: function(p) {
      var ratio;
      this._super(p, {
        x: 0,
        y: 0,
        z: 0,
        asset: Game.assets.map.bg,
        type: Q.SPRITE_NONE
      });
      this.imgEl = this.asset();
      ratio = this.imgEl.width / this.imgEl.height;
      // background cover vertically
      this.imgEl.width = Q.width + 10;
      this.imgEl.height = this.imgEl.width * ratio;
      // find background draw start point to achive viewport.centerX == imgEl.centerX
      this.p.deltaX = (this.imgEl.width - Q.width) / 2;
      return this.p.deltaY = (this.imgEl.height - Q.height) / 2;
    },
    draw: function(ctx) {
      var offsetX, offsetY, viewport;
      viewport = this.stage.viewport;
      if (viewport) {
        offsetX = viewport.centerX - Q.width / 2;
        offsetY = viewport.centerY - Q.height / 2;
      } else {
        offsetX = 0;
        offsetY = 0;
      }
      return ctx.drawImage(this.imgEl, offsetX - this.p.deltaX, offsetY - this.p.deltaY, this.imgEl.width, this.imgEl.height);
    }
  });

  // ctx.drawImage @imgEl, 0, 0
  Q = Game.Q;

  // animations object
  Q.animations("deadZombie", {
    intro: {
      frames: [16, 17, 18, 19, 20, 21],
      rate: 1 / 3,
      next: "stand"
    },
    stand: {
      frames: [21],
      rate: 1
    }
  });

  // human object and logic
  Q.Sprite.extend("DeadZombie", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        vx: 0,
        z: 18,
        sheet: "zombie",
        sprite: "deadZombie",
        type: Game.SPRITE_NONE,
        collisionMask: Game.SPRITE_TILES
      });
      this.add("2d, animation");
      // animations
      return this.play("intro");
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("human", {
    intro: {
      frames: [0, 1, 2, 3],
      rate: 0.7,
      next: "stand"
    },
    stand: {
      frames: [4, 5, 6],
      rate: 1 / 3
    },
    outro: {
      frames: [3, 2, 1, 0],
      rate: 0.8,
      loop: false,
      trigger: "outro"
    }
  });

  // human object and logic
  Q.Sprite.extend("Human", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        vx: 0,
        z: 20,
        timeInvincible: 4,
        sheet: "human",
        sprite: "human",
        type: Game.SPRITE_HUMAN,
        collisionMask: Game.SPRITE_TILES,
        sensor: true
      });
      this.add("2d, animation");
      // animations
      this.play("intro");
      // audio
      Q.AudioManager.add(Game.audio.humanCreated);
      // events
      this.on("sensor", this, "sensor");
      return this.on("outro", this, "die");
    },
    step: function(dt) {
      if (this.p.timeInvincible > 0) {
        return this.p.timeInvincible = Math.max(this.p.timeInvincible - dt, 0);
      }
    },
    sensor: function(obj) {
      if (obj.isA("Zombie") && this.p.timeInvincible === 0) {
        // turn to zombie again
        obj.play("attack", 10);
        this.play("outro");
      }
      if (obj.isA("ZombiePlayer")) {
        this.play("outro");
        return this.p.zombiePlayerSensor = true;
      }
    },
    die: function() {
      var randomBool, zombie;
      this.destroy();
      randomBool = Math.floor(Math.random() * 2);
      zombie = this.stage.insert(new Q.Zombie({
        x: this.p.x,
        y: this.p.y,
        startLeft: randomBool
      }));
      if (!this.p.zombiePlayerSensor) {
        return zombie.p.wasHuman = true;
      }
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("player", {
    stand: {
      frames: [1],
      rate: 1
    },
    run: {
      frames: [0, 1, 2, 1],
      rate: 1 / 4
    },
    hit: {
      frames: [4],
      loop: false,
      rate: 1,
      next: "stand"
    },
    jump: {
      frames: [3, 4, 5, 4],
      rate: 1 / 3
    }
  });

  Q.animations("playerWithGun", {
    stand: {
      frames: [1],
      rate: 1
    },
    run: {
      frames: [0, 1, 2, 1],
      rate: 1 / 4
    },
    hit: {
      frames: [3],
      loop: false,
      rate: 1,
      next: "stand"
    },
    jump: {
      frames: [3],
      rate: 1
    }
  });

  // player object and logic
  Q.Sprite.extend("Player", {
    init: function(p) {
      this._super(p, {
        lifePoints: Q.state.get("lives"),
        timeInvincible: 0,
        timeToNextSave: 0,
        x: 0,
        y: 0,
        z: 100,
        savedPosition: {},
        hasKey: false,
        sheet: "player",
        sprite: "player",
        type: Game.SPRITE_PLAYER,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_ENEMY | Game.SPRITE_PLAYER_COLLECTIBLE
      });
      this.add("2d, platformerControlsGaze, animation");
      if (Q.state.get("hasGun")) {
        this.add("gun");
      }
      this.p.jumpSpeed = -660;
      this.p.speed = 220;
      this.p.savedPosition.x = this.p.x;
      this.p.savedPosition.y = this.p.y;
      // audio
      Q.AudioManager.add(Game.audio.playerBg, {
        loop: true
      });
      // events
      this.on("bump.left, bump.right, bump.bottom, bump.top", this, "collision");
      return this.on("player.outOfMap", this, "restore");
    },
    step: function(dt) {
      var a, p, tri;
      // if invincible, flash opacity (with a triangle wave)
      if (this.p.timeInvincible > 0) {
        a = 0.3; // amplitude (triangle goes [-a, a])
        p = 1.25; // period
        tri = (2 * a / Math.PI) * Math.asin(Math.sin((2 * Math.PI / p) * this.p.timeInvincible));
        this.p.opacity = tri + (1.0 - a);
      } else {
        this.p.opacity = 1.0;
      }
      if (this.p.direction === "left") {
        this.p.flip = "x";
        this.p.points = [[-15, -50], [25, -50], [25, 50], [-15, 50]];
      }
      if (this.p.direction === "right") {
        this.p.flip = false;
        this.p.points = [[-25, -50], [15, -50], [15, 50], [-25, 50]];
      }
      // do not allow to get out of level
      if (this.p.x > Game.map.p.w) {
        this.p.x = Game.map.p.w;
      }
      if (this.p.x < 0) {
        this.p.x = 0;
      }
      // save
      if (this.p.timeToNextSave > 0) {
        this.p.timeToNextSave = Math.max(this.p.timeToNextSave - dt, 0);
      }
      if (this.p.timeToNextSave <= 0) {
        this.savePosition();
      }
      // collision with enemy timeout
      if (this.p.timeInvincible > 0) {
        this.p.timeInvincible = Math.max(this.p.timeInvincible - dt, 0);
      }
      // check if out of map
      if (this.p.y > Game.map.p.h) {
        this.updateLifePoints();
        this.trigger("player.outOfMap");
        this.p.willBeDead = false;
      }
      // animations
      if (this.p.vy !== 0) {
        this.play("jump");
      } else if (this.p.vx !== 0) {
        this.play("run");
      } else {
        this.play("stand");
      }
      // gun
      if (this.gunStep != null) {
        return this.gunStep(dt);
      }
    },
    collision: function(col) {
      if (col.obj.isA("Zombie") && this.p.timeInvincible === 0) {
        this.updateLifePoints();
        col.obj.play("attack", 10);
        // will be invincible for 1 second
        return this.p.timeInvincible = 3;
      }
    },
    savePosition: function() {
      var ground;
      ground = Q.stage().locate(this.p.x, this.p.y + this.p.h / 2 + 0.5, Game.SPRITE_TILES);
      if (ground) {
        this.p.savedPosition.x = this.p.x;
        this.p.savedPosition.y = this.p.y;
        return this.p.timeToNextSave = 2;
      }
    },
    updateLifePoints: function(newLives) {
      var isOutOfMap, zombiePlayer;
      if (newLives != null) {
        this.p.lifePoints += newLives;
      } else {
        isOutOfMap = this.p.y > Game.map.p.h;
        if (isOutOfMap) {
          Game.infoLabel.lifeLostFall();
        } else {
          Game.infoLabel.lifeLostZombie();
        }
        this.p.lifePoints -= 1;
        this.play("hit", 1);
        Q.AudioManager.add(Game.audio.playerHit);
        if (this.p.lifePoints < 0) {
          if (this.p.wasZombie || isOutOfMap) {
            this.destroy();
            Game.stageGameOverScreen();
            return;
          }
          // zombie mode!
          zombiePlayer = this.stage.insert(new Q.ZombiePlayer({
            x: (() => {
              if (this.p.y > Game.map.p.h) {
                return this.p.savedPosition.x;
              } else {
                return this.p.x;
              }
            })(),
            y: (() => {
              if (this.p.y > Game.map.p.h) {
                return this.p.savedPosition.y;
              } else {
                return this.p.y;
              }
            })()
          }));
          Game.setCameraTo(this.stage, zombiePlayer);
          zombiePlayer.p.direction = this.p.direction;
          this.destroy();
        }
        if (this.p.lifePoints === 0) {
          Game.infoLabel.lifeLevelLow();
        }
      }
      // always update label
      return Q.state.set("lives", this.p.lifePoints);
    },
    restore: function() {
      this.p.timeInvincible = 5;
      this.p.x = this.p.savedPosition.x;
      this.p.y = this.p.savedPosition.y + 0.25 * Game.assets.map.tileSize;
      this.p.vx = 0;
      return this.p.vy = 0;
    }
  });

  Q = Game.Q;

  
  Q.animations("zombie", {
    run: {
      frames: [0, 1, 2, 3],
      rate: 0.4
    },
    hit: {
      frames: [10],
      loop: false,
      rate: 1,
      next: "run"
    },
    attack: {
      frames: [8, 9, 10, 11],
      loop: false,
      rate: 1 / 2,
      next: "run"
    },
    fall: {
      frames: [4, 5, 6, 7, 7, 7, 7],
      rate: 1 / 5,
      loop: false,
      next: "run"
    }
  });

  
  Q.Sprite.extend("Zombie", {
    init: function(p) {
      this._super(p, {
        lifePoints: 1,
        x: 0,
        y: 0,
        vx: 0,
        z: 20,
        canFallOff: true, // when chasing, zombie can fall off platform
        sheet: "zombie",
        sprite: "zombie",
        canSeeThePlayerTimeout: 0,
        type: Game.SPRITE_ENEMY,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_PLAYER | Game.SPRITE_BULLET | Game.SPRITE_HUMAN
      });
      Q.state.inc("enemiesCounter", 1);
      this.add("2d, animation, zombieAI");
      // events
      this.on("hit", this, "collision");
      this.on("bump.right", this, "hitFromRight");
      return this.on("bump.left", this, "hitFromLeft");
    },
    collision: function(col) {
      if (col.obj.isA("Bullet")) {
        this.play("hit");
        return this.decreaseLifePoints();
      }
    },
    hitFromRight: function(col) {
      // don't stop after collision
      return this.p.vx = col.impact;
    },
    hitFromLeft: function(col) {
      // don't stop after collision
      return this.p.vx = -col.impact;
    },
    step: function(dt) {
      if (this.zombieStep != null) {
        this.zombieStep(dt);
      }
      if (this.p.y > Game.map.p.h) {
        this.die(false);
      }
      // animations
      if (this.p.vy !== 0) {
        return this.play("fall");
      } else {
        return this.play("run");
      }
    },
    decreaseLifePoints: function() {
      this.p.lifePoints -= 1;
      if (this.p.lifePoints <= 0) {
        return this.die();
      }
    },
    die: function(turnToHuman = true) {
      this.destroy();
      if (!this.p.wasHuman && turnToHuman) {
        // replace zombie with human
        this.stage.insert(new Q.Human({
          x: this.p.x,
          y: this.p.y
        }));
      } else {
        this.stage.insert(new Q.DeadZombie({
          x: this.p.x,
          y: this.p.y
        }));
      }
      // update enemies counter
      return Q.state.dec("enemiesCounter", 1);
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("zombiePlayer", {
    stand: {
      frames: [4],
      rate: 1
    },
    run: {
      frames: [3, 4, 5, 4],
      rate: 1 / 3
    },
    jump: {
      frames: [3],
      rate: 1
    },
    intro: {
      frames: [0, 1, 0, 1, 0, 1],
      rate: 0.8,
      next: "stand",
      trigger: "ready"
    }
  });

  // main object and logic
  Q.Sprite.extend("ZombiePlayer", {
    init: function(p) {
      this._super(p, {
        timeToNextSave: 0,
        x: 0,
        y: 0,
        z: 100,
        savedPosition: {},
        sheet: "zombie_player",
        sprite: "zombiePlayer",
        type: Game.SPRITE_ZOMBIE_PLAYER,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_HUMAN | Game.SPRITE_PLAYER_COLLECTIBLE
      });
      this.add("2d, animation");
      this.p.jumpSpeed = -660;
      this.p.speed = 220;
      this.p.savedPosition.x = this.p.x;
      this.p.savedPosition.y = this.p.y;
      this.p.playerDirection = this.p.direction;
      Game.infoLabel.zombieModeOn();
      this.play("intro", 10);
      // events
      this.on("player.outOfMap", this, "die");
      return this.on("ready", this, "enableZombieMode");
    },
    enableZombieMode: function() {
      this.add("platformerControlsGaze");
      this.p.direction = this.p.playerDirection;
      Game.infoLabel.zombieModeOnNext();
      Game.currentLevelData.zombieModeFound = true;
      Game.playerAvatar.changeToZombie();
      Game.healthImg.changeToHalf();
      // audio
      Q.AudioManager.remove(Game.audio.playerBg);
      return Q.AudioManager.add(Game.audio.zombieMode, {
        loop: true
      });
    },
    step: function(dt) {
      if (this.p.direction === "left") {
        this.p.flip = "x";
      }
      if (this.p.direction === "right") {
        this.p.flip = false;
      }
      // check if out of map
      if (this.p.y > Game.map.p.h) {
        this.trigger("player.outOfMap");
      }
      // do not allow to get out of level
      if (this.p.x > Game.map.p.w) {
        this.p.x = Game.map.p.w;
      }
      if (this.p.x < 0) {
        this.p.x = 0;
      }
      // save
      if (this.p.timeToNextSave > 0) {
        this.p.timeToNextSave = Math.max(this.p.timeToNextSave - dt, 0);
      }
      if (this.p.timeToNextSave === 0) {
        this.savePosition();
        this.p.timeToNextSave = 4;
      }
      // animations
      if (this.p.vy !== 0) {
        return this.play("jump");
      } else if (this.p.vx !== 0) {
        return this.play("run");
      } else {
        return this.play("stand");
      }
    },
    savePosition: function() {
      var dirX, ground;
      dirX = this.p.vx / Math.abs(this.p.vx);
      ground = Q.stage().locate(this.p.x, this.p.y + this.p.h / 2 + 1, Game.SPRITE_TILES);
      if (ground) {
        this.p.savedPosition.x = this.p.x;
        return this.p.savedPosition.y = this.p.y;
      }
    },
    die: function() {
      // zombie mode ends
      Game.stageGameOverScreen();
      return this.destroy();
    }
  });

  Q = Game.Q;

  Q.UI.BulletsCounter = Q.UI.Text.extend("UI.BulletsCounter", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        label: Q.state.get("bullets") + "",
        size: 34,
        color: "#f2da38",
        family: "Boogaloo"
      });
      this.p.x = -this.p.img.w / 2 - this.p.w / 2 - 12;
      return Q.state.on("change.bullets", this, "updateLabel");
    },
    updateLabel: function(bullets) {
      return this.p.label = bullets + "";
    }
  });

  Q = Game.Q;

  Q.UI.BulletsImg = Q.Sprite.extend("Q.UI.BulletsImg", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_bullets"
      });
    }
  });

  Q = Game.Q;

  Q.UI.EnemiesAvatar = Q.Sprite.extend("Q.UI.EnemiesAvatar", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_zombie"
      });
      this.p.x = Q.width - this.p.w / 2;
      return this.p.y = this.p.h / 2 + 8;
    }
  });

  Q = Game.Q;

  Q.UI.EnemiesCounter = Q.UI.Text.extend("UI.EnemiesCounter", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        label: Q.state.get("enemiesCounter") + "",
        size: 34,
        color: "#c4da4a",
        family: "Boogaloo"
      });
      this.p.w = 60;
      return Q.state.on("change.enemiesCounter", this, "updateLabel");
    },
    updateLabel: function(enemiesCounter) {
      return this.p.label = enemiesCounter + "";
    }
  });

  Q = Game.Q;

  Q.UI.HealthCounter = Q.UI.Text.extend("UI.HealthCounter", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        label: Q.state.get("lives") + "",
        size: 34,
        color: "#ec655d",
        family: "Boogaloo"
      });
      this.p.x = -this.p.img.w / 2 - this.p.w / 2 - 6;
      return Q.state.on("change.lives", this, "updateLabel");
    },
    updateLabel: function(lives) {
      if (lives >= 0) {
        return this.p.label = lives + "";
      } else {
        return this.p.label = "0";
      }
    }
  });

  Q = Game.Q;

  Q.UI.HealthImg = Q.Sprite.extend("Q.UI.HealthImg", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_health"
      });
    },
    changeToHalf: function() {
      return this.p.sheet = "hud_health_half";
    }
  });

  Q = Game.Q;

  Q.UI.InfoLabel = Q.UI.Text.extend("UI.InfoLabel", {
    init: function(p, defaultProps) {
      return this._super(p, {
        x: 0,
        y: 0,
        label: "",
        color: "#222221",
        size: 24,
        family: "Boogaloo",
        pendingLabel: ""
      });
    },
    speak: function(phrase) {
      if (false) { // TODO: Add this in :)
        return responsiveVoice.speak(phrase, "UK English Male");
      }
    },
    changeLabel: function(new_label) {
      var self;
      if (new_label === this.pendingLabel) {
        return;
      }
      this.pendingLabel = new_label;
      this.afterLabelChange("...");
      self = this;
      return setTimeout((function() {
        self.afterLabelChange(new_label);
        return self.speak(new_label);
      }), 250);
    },
    afterLabelChange: function(new_label) {
      if (new_label) {
        this.p.label = new_label;
      }
      this.calcSize();
      this.p.container.p.x = this.p.offsetLeft + this.p.w / 2 + 10;
      this.p.container.fit(5, 10);
      return Q._generatePoints(this);
    },
    tutorial: function() {
      return this.changeLabel("If you can complete this tutorial you're ready to save some zombies");
    },
    intro: function() {
      return this.changeLabel("I need to find the way out of here");
    },
    keyNeeded: function() {
      return this.changeLabel("I need the key");
    },
    doorOpen: function() {
      return this.changeLabel("Nice! Now I need to enter the door");
    },
    gunFound: function() {
      return this.changeLabel("I found the gun, I can shoot zombies");
    },
    outOfBullets: function() {
      return this.changeLabel("I'm out of ammo");
    },
    keyFound: function() {
      return this.changeLabel("I found the key, now I need to find the door");
    },
    clear: function() {
      return this.afterLabelChange("");
    },
    lifeLevelLow: function() {
      return this.changeLabel("No more spare lives! I need to be more careful");
    },
    extraLifeFound: function() {
      return this.changeLabel("I feel better now!");
    },
    lifeLostZombie: function() {
      var label, random;
      random = Math.floor(Math.random() * 3);
      if (random === 0) {
        label = "Ouch!";
      } else if (random === 1) {
        label = "I've been bitten!";
      } else {
        label = "That hurts!";
      }
      return this.changeLabel(label);
    },
    lifeLostFall: function() {
      var label, random;
      random = Math.floor(Math.random() * 3);
      if (random === 0) {
        label = "Ouch!";
      } else if (random === 1) {
        label = "Oops!";
      } else {
        label = "That hurt!";
      }
      return this.changeLabel(label);
    },
    zombieModeOn: function() {
      return this.changeLabel("I was bitten too many times. ");
    },
    zombieModeOnNext: function() {
      return this.changeLabel("I've turned into a zombie. Nooo!");
    },
    zombieModeOff: function() {
      return this.changeLabel("Ok, back to business");
    }
  });

  Q = Game.Q;

  Q.UI.InventoryKey = Q.Sprite.extend("Q.UI.InventoryKey", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_key_empty"
      });
      return Q.state.on("change.hasKey", this, "updateSheet");
    },
    updateSheet: function(hasKey) {
      if (hasKey === true) {
        return this.p.sheet = "hud_key_collected";
      } else {
        return this.p.sheet = "hud_key_empty";
      }
    }
  });

  Q = Game.Q;

  Q.UI.LinearGradient = Q.Sprite.extend("Q.UI.LinearGradient", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        z: 0,
        asset: Game.assets.gradient
      });
    },
    draw: function(ctx) {
      var img, ptrn;
      img = this.asset();
      ptrn = ctx.createPattern(img, 'repeat');
      ctx.fillStyle = ptrn;
      return ctx.fillRect(0, 0, Q.width, this.p.h);
    }
  });

  Q = Game.Q;

  Q.UI.PlayerAvatar = Q.Sprite.extend("Q.UI.PlayerAvatar", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "hud_player"
      });
      this.p.x = this.p.w / 2;
      return this.p.y = this.p.h / 2;
    },
    changeToZombie: function() {
      return this.p.sheet = "hud_zombie_player";
    },
    changeToPlayer: function() {
      return this.p.sheet = "hud_player";
    }
  });

  Q = Game.Q;

  Q.UI.RadialGradient = Q.Sprite.extend("Q.UI.RadialGradient", {
    init: function(p) {
      this._super(p, {
        x: Q.width / 2,
        y: Q.height / 2,
        w: Q.width,
        h: Q.height
      });
      return console.log(this.p);
    },
    draw: function(ctx) {
      var rad;
      rad = ctx.createRadialGradient(0, 0, this.p.w / 3, 0, 0, this.p.w / 2 + this.p.w / 4);
      rad.addColorStop(0, 'rgba(0,0,0,0)');
      rad.addColorStop(1, 'rgba(0,0,0,1)');
      // rad.addColorStop(0, 'rgba(255,0,0,0.5)')
      // rad.addColorStop(1, 'rgba(0,255,0,1)')
      ctx.fillStyle = rad;
      ctx.fillRect(-this.p.cx, -this.p.cy, this.p.w, this.p.h);
      return ctx.fill();
    }
  });

  Q = Game.Q;

  // animations object
  Q.animations("bullet", {
    fly: {
      frames: [0, 1, 2, 3, 4, 5],
      rate: 0.3
    }
  });

  Q.Sprite.extend("Bullet", {
    init: function(p) {
      this._super(p, {
        range: Q.width / 2,
        sheet: "bullet",
        sprite: "bullet",
        speed: 700,
        gravity: 0,
        type: Game.SPRITE_BULLET,
        collisionMask: Game.SPRITE_TILES | Game.SPRITE_ENEMY
      });
      this.add("2d, animation");
      this.play("fly");
      this.p.initialX = this.p.x;
      this.p.initialY = this.p.y;
      return this.on("hit", this, "collision");
    },
    step: function(dt) {
      if (this.p.direction === "left") {
        this.p.vx = -this.p.speed;
        this.p.flip = "x";
      } else {
        this.p.vx = this.p.speed;
        this.p.flip = false;
      }
      if (this.p.x > Game.map.width || this.p.x < 0) {
        this.die();
      }
      if (this.p.x > this.p.initialX + this.p.range || this.p.x < this.p.initialX - this.p.range) {
        return this.die();
      }
    },
    collision: function(col) {
      this.p.x -= col.separate[0];
      this.p.y -= col.separate[1];
      // difference for level statistics
      if (col.obj.isA("Zombie")) {
        return this.destroy();
      } else {
        return this.die();
      }
    },
    die: function() {
      Game.currentLevelData.bullets.waisted += 1;
      return this.destroy();
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Door", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "door_closed",
        opened: false,
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      this.p.y -= this.p.h / 2 - Game.assets.map.tileSize / 2;
      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player") || obj.isA("ZombiePlayer")) {
        if ((Q.state.get("hasKey")) && !this.p.opened) {
          // remove the key and open the door
          Q.state.set("hasKey", false);
          this.p.opened = true;
          this.p.sheet = "door_open";
          Q.state.set("canEnterDoor", true);
          return Game.infoLabel.doorOpen();
        } else if (!this.p.opened) {
          return Game.infoLabel.keyNeeded();
        } else if (this.p.opened && (Q.inputs['up'] || Q.inputs['action'] || Q.inputs['enter'])) {
          // enter the door
          obj.destroy();
          // get game statistics
          Game.currentLevelData.zombies.healed = this.stage.lists.Human != null ? this.stage.lists.Human.length : 0;
          if (Q.state.get("currentLevel") > 0) {
            return Game.stageEndLevelScreen();
          } else {
            return Game.stageScreen("tutorialSummary");
          }
        }
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("ExitSign", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "exit_sign",
        type: Game.SPRITE_NONE
      });
      return this.p.y -= this.p.h / 2 - Game.assets.map.tileSize / 2;
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Gun", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "gun",
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true,
        bullets: 6
      });
      this.p.y -= 15;
      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player")) {
        Q.state.set("hasGun", true);
        obj.add("gun");
        Game.infoLabel.gunFound();
        // number of bullets depends of the gun
        obj.p.noOfBullets = this.p.bullets;
        Q.state.set("bullets", this.p.bullets);
        Game.currentLevelData.bullets.available = this.p.bullets;
        Q.AudioManager.add(Game.audio.collected);
        return this.destroy();
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Heart", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "heart",
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      this.p.y -= 15;
      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player")) {
        obj.updateLifePoints(1);
        Game.infoLabel.extraLifeFound();
        Q.AudioManager.add(Game.audio.collected);
        this.destroy();
        return Game.currentLevelData.health.collected += 1;
      }
    }
  });

  Q = Game.Q;

  Q.Sprite.extend("Key", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        z: 10,
        sheet: "key",
        type: Game.SPRITE_PLAYER_COLLECTIBLE,
        sensor: true
      });
      // range: 6
      // speed: 6
      // gravity: 0
      this.p.y -= 15;
      // @add("2d")
      // @p.initialY = @p.y
      // @p.vy = @p.speed

      // events
      return this.on("sensor", this, "sensor");
    },
    sensor: function(obj) {
      if (obj.isA("Player") || obj.isA("ZombiePlayer")) {
        Q.state.set("hasKey", true);
        Game.infoLabel.keyFound();
        Q.AudioManager.add(Game.audio.collected);
        return this.destroy();
      }
    }
  });

  // step: (dt) ->
  //   if @p.initialY + @p.range < @p.y
  //     @p.vy = -@p.speed

  //   if @p.initialY - @p.range > @p.y
  //     @p.vy = @p.speed
  Q = Game.Q;

  Q.Adjuster = {
    add: function(stage, x, y, w, h, label, prefKey) {
      var cellsize, decButton, fontsize, fontsize_symbols, incButton, valText;
      // Add 2 buttons that increment/decrement a label in the middle
      cellsize = Math.min(h, w / 3);
      fontsize = Math.floor(h / 5);
      fontsize_symbols = Math.floor(h / 2);
      // Left hand: decrement
      decButton = stage.insert(new Q.UI.Button({
        x: x - cellsize,
        y: y,
        fill: "#c4da4a",
        w: cellsize,
        h: cellsize,
        radius: 10,
        fontColor: "#353b47",
        font: "400 80px Jolly Lodger",
        label: "-",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      // Right hand: increment
      incButton = stage.insert(new Q.UI.Button({
        x: x + cellsize,
        fill: "#c4da4a",
        y: y,
        w: cellsize,
        h: cellsize,
        radius: 10,
        fontColor: "#353b47",
        font: "400 " + fontsize_symbols + "px Jolly Lodger",
        label: "+",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      }));
      // Label for setting
      stage.insert(new Q.UI.Text({
        x: x,
        y: y - cellsize / 2 - fontsize / 2,
        label: label,
        color: "#f2da38",
        family: "Boogaloo",
        size: fontsize
      }));
      // Value for setting
      valText = stage.insert(new Q.UI.Text({
        x: x,
        y: y,
        label: Game.preferences[prefKey].toFixed(1),
        color: "#f2da38",
        family: "Boogaloo",
        size: fontsize
      }));
      // # Callbacks
      // decButton.on "click", (e) ->
      //   console.log('-')

      // incButton.on "click", (e) ->
      //   console.log('+')

      // Callbacks
      decButton.on("click", function(e) {
        Game.preferences[prefKey] -= 0.1;
        valText.p.label = Game.preferences[prefKey].toFixed(1);
        console.log(Game.preferences['uiScale']);
        return console.log(Game.preferences['dwellTime']);
      });
      return incButton.on("click", function(e) {
        Game.preferences[prefKey] += 0.1;
        valText.p.label = Game.preferences[prefKey].toFixed(1);
        console.log(Game.preferences['uiScale']);
        return console.log(Game.preferences['dwellTime']);
      });
    }
  };

  Q = Game.Q;

  Q.UI.ArrowButton = Q.UI.Button.extend("UI.ArrowButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "arrow_button",
        fontColor: "#595f5f",
        font: "400 32px Jolly Lodger",
        page: 0,
        fontColor: "#404444",
        align: 'center',
        flip: false
      });
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      return this.on('click', () => {
        return Game.stageMoreLevels(this.p.page);
      });
    }
  });

  Q = Game.Q;

  Q.UI.AudioButton = Q.UI.Button.extend("UI.AudioButton", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "mute", // button that will trigger click event
        isSmall: true
      });
      if (this.p.isSmall) {
        if (Game.isMuted) {
          this.p.sheet = "hud_audio_off_button_small";
        } else {
          this.p.sheet = "hud_audio_on_button_small";
        }
      } else {
        if (Game.isMuted) {
          this.p.sheet = "hud_audio_off_button";
        } else {
          this.p.sheet = "hud_audio_on_button";
        }
      }
      this.size(true); // force resize 
      return this.on('click', () => {
        if (!Game.isMuted) {
          Q.AudioManager.mute();
          if (this.p.isSmall) {
            this.p.sheet = "hud_audio_off_button_small";
          } else {
            this.p.sheet = "hud_audio_off_button";
          }
          Game.isMuted = true;
          return Game.trackEvent("Audio Button", "clicked", "off");
        } else {
          Q.AudioManager.unmute();
          if (this.p.isSmall) {
            this.p.sheet = "hud_audio_on_button_small";
          } else {
            this.p.sheet = "hud_audio_on_button";
          }
          Game.isMuted = false;
          return Game.trackEvent("Audio Button", "clicked", "on");
        }
      });
    }
  });

  Q = Game.Q;

  Q.UI.Authors = Q.UI.Text.extend("UI.Authors", {
    init: function(p) {
      this._super(p, {
        label: "Created by @krzysu and @pawelmadeja, adapted for eye gaze by @SpecialEffect",
        color: "#c4da4a",
        family: "Boogaloo",
        size: 22
      });
      this.p.x = Q.width / 2;
      return this.p.y = Q.height - this.p.h / 2;
    }
  });

  Q = Game.Q;

  Q.UI.CursorButton = Q.UI.Button.extend("UI.CursorButton", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "show_cursor", // button that will trigger click event
        isSmall: true
      });
      this.update_sheet(p);
      this.size(true); // force resize 
      return this.on('click', () => {
        var element;
        if (!Game.showCursor) {
          element = document.getElementById("quintus_container");
          element.style.cursor = "auto";
          Game.showCursor = true;
          Game.trackEvent("Cursor Button", "clicked", "off");
        } else {
          element = document.getElementById("quintus_container");
          element.style.cursor = "none";
          Game.showCursor = false;
          Game.trackEvent("Cursor Button", "clicked", "on");
        }
        this.update_sheet();
        // Remember response in local storage
        return localStorage.setItem(Game.storageKeys.showCursor, Game.showCursor);
      });
    },
    update_sheet: function() {
      if (this.p.isSmall) {
        if (Game.showCursor) {
          return this.p.sheet = "hud_cursor_on_button_small";
        } else {
          return this.p.sheet = "hud_cursor_off_button_small";
        }
      } else {
        if (Game.showCursor) {
          return this.p.sheet = "hud_cursor_on_button";
        } else {
          return this.p.sheet = "hud_cursor_off_button";
        }
      }
    }
  });

  Q = Game.Q;

  Q.UI.DoorButton = Q.UI.Button.extend("UI.DoorButton", {
    init: function(p) {
      var onChangeHidden;
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        w: 120,
        h: 120,
        hidden: true,
        fill: "#c4da4a",
        radius: 10,
        fontColor: "#353b47",
        font: "400 58px Jolly Lodger",
        label: "enter",
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT
      });
      if (this.p.enabled === false) {
        this.p.sheet = "ui_level_button_locked";
        this.p.label = false;
      }
      this.on("click", function(e) {
        Q.inputs['enter'] = 1;
        return Q.input.trigger('enter');
      });
      this.on("release", function(e) {
        return Q.inputs['enter'] = 0;
      });
      onChangeHidden = (ctx) => {
        return () => {
          return ctx.p.hidden = !Q.state.get("canEnterDoor");
        };
      };
      return Q.state.on("change.canEnterDoor", onChangeHidden(this));
    }
  });

  Q = Game.Q;

  Q.UI.HelpText = Q.UI.Text.extend("UI.Text", {
    init: function(p) {
      return this._super(p, {
        label: "",
        color: "#f2da38",
        family: "Jolly Lodger",
        size: 32
      });
    }
  });

  Q = Game.Q;

  Q.UI.LevelButton = Q.UI.Button.extend("UI.LevelButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "ui_level_button",
        fontColor: "#595f5f",
        font: "400 70px Jolly Lodger"
      });
      if (this.p.level > 0) {
        this.p.label = "" + this.p.level;
      }
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      if (this.p.enabled === false) {
        this.p.sheet = "ui_level_button_locked";
        this.p.label = false;
      }
      return this.on('click', () => {
        if (this.p.enabled) {
          if (this.p.level === 0) {
            return Game.stageTutorial();
          } else if (this.p.level === 1) {
            return Game.stageScreen("controls");
          } else {
            return Game.stageLevel(this.p.level);
          }
        } else {
          return Game.trackEvent("Level Button", "clicked", "locked");
        }
      });
    }
  });

  Q = Game.Q;

  Q.UI.LevelScoreImg = Q.Sprite.extend("Q.UI.LevelScoreImg", {
    init: function(p) {
      this._super(p, {
        x: 0,
        y: 0,
        sheet: "ui_level_score"
      });
      if (this.p.empty) {
        return this.p.sheet = "ui_level_score_empty";
      }
    }
  });

  Q = Game.Q;

  Q.UI.LevelScoreImgSmall = Q.Sprite.extend("Q.UI.LevelScoreImgSmall", {
    init: function(p) {
      return this._super(p, {
        x: 0,
        y: 0,
        sheet: "ui_level_score_small"
      });
    }
  });

  Q = Game.Q;

  Q.UI.MenuButton = Q.UI.Button.extend("UI.MenuButton", {
    init: function(p) {
      this._super(p, {
        x: Q.width - 30,
        y: 170,
        z: 100,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        keyActionName: "escape", // button that will trigger click event
        isSmall: true
      });
      if (this.p.isSmall) {
        this.p.sheet = "hud_back_button_small";
      } else {
        this.p.sheet = "hud_back_button";
      }
      this.size(true); // force resize 
      return this.on('click', () => {
        Game.stageLevelSelectScreen();
        return Game.trackEvent("Menu Button", "clicked");
      });
    }
  });

  Q = Game.Q;

  Q.UI.MoreLevelsButton = Q.UI.Button.extend("UI.MoreLevelsButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "ui_level_button",
        fontColor: "#595f5f",
        font: "400 32px Jolly Lodger",
        page: 0,
        fontColor: "#404444",
        align: 'center'
      });
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      return this.on('click', () => {
        return Game.stageMoreLevels(this.p.page);
      });
    }
  });

  Q = Game.Q;

  Q.UI.PauseButton = Q.UI.Button.extend("UI.PauseButton", {
    init: function(p) {
      var pausedScreen, pausedText;
      this._super(p, {
        x: Q.width - 30,
        y: 110,
        z: 100,
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        isPaused: false,
        keyActionName: "pause", // button that will trigger click event
        isSmall: true
      });
      if (this.p.isSmall) {
        this.p.sheet = "hud_pause_button_small";
      } else {
        this.p.sheet = "hud_pause_button";
      }
      this.size(true); // force resize 
      pausedScreen = new Q.UI.Container({
        x: Q.width / 2,
        y: Q.height / 2,
        w: Q.width,
        h: Q.height,
        z: 50,
        fill: "rgba(0,0,0,0.75)"
      });
      pausedText = new Q.UI.Text({
        x: 0,
        y: 0,
        label: "Paused",
        color: "#f2da38",
        family: "Jolly Lodger",
        size: 100
      });
      return this.on('click', () => {
        if (!this.isPaused) {
          Q.stage().pause();
          Q.AudioManager.stopAll();
          this.isPaused = true;
          this.stage.insert(pausedScreen);
          pausedScreen.insert(pausedText);
          return Game.trackEvent("Pause Button", "clicked", "on");
        } else {
          Q.stage().unpause();
          if (!Game.isMuted) {
            Q.AudioManager.playAll();
          }
          this.isPaused = false;
          this.stage.remove(pausedScreen);
          return Game.trackEvent("Pause Button", "clicked", "off");
        }
      });
    }
  });

  Q = Game.Q;

  Q.UI.SettingsButton = Q.UI.Button.extend("UI.SettingsButton", {
    init: function(p) {
      this._super(p, {
        type: Q.SPRITE_UI | Q.SPRITE_DEFAULT,
        sheet: "ui_level_button",
        fontColor: "#595f5f",
        font: "400 32px Jolly Lodger"
      });
      // label: "Settings"
      this.p.sheetW = 172;
      this.p.sheetH = 130;
      this.p.cx = this.p.sheetW / 2;
      this.p.cy = this.p.sheetH / 2;
      return this.on('click', () => {
        return Game.stageScreen("settingsPlaceholder");
      });
    }
  });

}).call(this);
